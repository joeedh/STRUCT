<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <base data-ice="baseUrl" href="../../">
  <title data-ice="title">src/struct_intern.js | nstructjs</title>
  <link type="text/css" rel="stylesheet" href="css/style.css">
  <link type="text/css" rel="stylesheet" href="css/prettify-tomorrow.css">
  <script src="script/prettify/prettify.js"></script>
  <script src="script/manual.js"></script>
<meta name="description" content="ProtoBuf-like serialization system optimized for JS"><meta property="twitter:card" content="summary"><meta property="twitter:title" content="nstructjs"><meta property="twitter:description" content="ProtoBuf-like serialization system optimized for JS"></head>
<body class="layout-container" data-ice="rootContainer">

<header>
  <a href="./">Home</a>
  <a href="./manual/index.html" data-ice="manualHeaderLink">Manual</a>
  <a href="identifiers.html">Reference</a>
  <a href="source.html">Source</a>
  
  <div class="search-box">
  <span>
    <img src="./image/search.png">
    <span class="search-input-edge"></span><input class="search-input"><span class="search-input-edge"></span>
  </span>
    <ul class="search-result"></ul>
  </div>
</header>

<nav class="navigation" data-ice="nav"><div>
  <ul>
    
  <li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/struct_binpack.js~unpack_context.html">unpack_context</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/struct_filehelper.js~Block.html">Block</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/struct_filehelper.js~FileError.html">FileError</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/struct_filehelper.js~FileHelper.html">FileHelper</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/struct_filehelper.js~FileParams.html">FileParams</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/struct_intern.js~STRUCT.html">STRUCT</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/struct_intern2.js~StructArrayField.html">StructArrayField</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/struct_intern2.js~StructBoolField.html">StructBoolField</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/struct_intern2.js~StructByteField.html">StructByteField</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/struct_intern2.js~StructDoubleField.html">StructDoubleField</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/struct_intern2.js~StructFieldType.html">StructFieldType</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/struct_intern2.js~StructFloatField.html">StructFloatField</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/struct_intern2.js~StructIntField.html">StructIntField</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/struct_intern2.js~StructIterField.html">StructIterField</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/struct_intern2.js~StructIterKeysField.html">StructIterKeysField</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/struct_intern2.js~StructShortField.html">StructShortField</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/struct_intern2.js~StructStaticArrayField.html">StructStaticArrayField</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/struct_intern2.js~StructStaticStringField.html">StructStaticStringField</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/struct_intern2.js~StructStringField.html">StructStringField</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/struct_intern2.js~StructStructField.html">StructStructField</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/struct_intern2.js~StructTStructField.html">StructTStructField</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/struct_intern2.js~StructUintField.html">StructUintField</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/struct_intern2.js~StructUshortField.html">StructUshortField</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/struct_parseutil.js~PUTIL_ParseError.html">PUTIL_ParseError</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/struct_parseutil.js~lexer.html">lexer</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/struct_parseutil.js~parser.html">parser</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/struct_parseutil.js~tokdef.html">tokdef</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/struct_parseutil.js~token.html">token</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/struct_util.js~IDGen.html">IDGen</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/struct_util.js~cachering.html">cachering</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/struct_util.js~set.html">set</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-decode_utf8">decode_utf8</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-encode_utf8">encode_utf8</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-pack_byte">pack_byte</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-pack_bytes">pack_bytes</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-pack_double">pack_double</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-pack_float">pack_float</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-pack_int">pack_int</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-pack_short">pack_short</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-pack_static_string">pack_static_string</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-pack_string">pack_string</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-pack_uint">pack_uint</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-pack_ushort">pack_ushort</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-test_utf8">test_utf8</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-unpack_byte">unpack_byte</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-unpack_bytes">unpack_bytes</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-unpack_double">unpack_double</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-unpack_float">unpack_float</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-unpack_int">unpack_int</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-unpack_short">unpack_short</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-unpack_static_string">unpack_static_string</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-unpack_string">unpack_string</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-unpack_uint">unpack_uint</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-unpack_ushort">unpack_ushort</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-versionCoerce">versionCoerce</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-versionLessThan">versionLessThan</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-versionToInt">versionToInt</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-write_scripts">write_scripts</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-fromJSON">fromJSON</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-packNull">packNull</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-toJSON">toJSON</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-get_callstack">get_callstack</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-is_obj_lit">is_obj_lit</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-print_stack">print_stack</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-truncateDollarSign">truncateDollarSign</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-inherit">inherit</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-readJSON">readJSON</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-readObject">readObject</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-register">register</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-setAllowOverriding">setAllowOverriding</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-truncateDollarSign">truncateDollarSign</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-useTinyEval">useTinyEval</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-validateStructs">validateStructs</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-writeJSON">writeJSON</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-writeObject">writeObject</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-StructFieldTypeMap">StructFieldTypeMap</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-StructEnum">StructEnum</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-StructTypeMap">StructTypeMap</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-StructTypes">StructTypes</a></span></span></li>
</ul>
</div>
</nav>

<div class="content" data-ice="content"><h1 data-ice="title">src/struct_intern.js</h1>
<pre class="source-code line-number raw-source-code"><code class="prettyprint linenums" data-ice="content">&quot;use strict&quot;;
let struct_util = require(&quot;./struct_util&quot;);
let struct_binpack = require(&quot;./struct_binpack&quot;);
let struct_parseutil = require(&quot;./struct_parseutil&quot;);
let struct_parser = require(&quot;./struct_parser&quot;);

let sintern2 = require(&quot;./struct_intern2.js&quot;);
let StructFieldTypeMap = sintern2.StructFieldTypeMap;

let warninglvl = 2;

function unmangle(name) {
  if (exports.truncateDollarSign) {
    return struct_util.truncateDollarSign(name);
  } else {
    return name;
  }
}

/*

class SomeClass {
  static newSTRUCT() {
    //returns a new, empty instance of SomeClass
  }
  
  loadSTRUCT(reader) {
    reader(this); //reads data into this instance
  }
  
  //the old api, that both creates and reads
  static fromSTRUCT(reader) {
    let ret = new SomeClass();
    reader(ret);
    return ret;
  }
}
SomeClass.STRUCT = `
SomeClass {
}
`
nstructjs.manager.add_class(SomeClass);

*/
let StructTypeMap = struct_parser.StructTypeMap;
let StructTypes = struct_parser.StructTypes;

let struct_parse = struct_parser.struct_parse;
let StructEnum = struct_parser.StructEnum;

let _static_envcode_null = &quot;&quot;;
let debug_struct = 0;
let packdebug_tablevel = 0;

//truncate webpack-mangled names
exports.truncateDollarSign = true;

function gen_tabstr(tot) {
  var ret = &quot;&quot;;

  for (let i = 0; i &lt; tot; i++) {
    ret += &quot; &quot;;
  }

  return ret;
}

let packer_debug, packer_debug_start, packer_debug_end;

if (debug_struct) {
  packer_debug = function (msg) {
    if (msg !== undefined) {
      let t = gen_tabstr(packdebug_tablevel);
      console.log(t + msg);
    } else {
      console.log(&quot;Warning: undefined msg&quot;);
    }
  };
  packer_debug_start = function (funcname) {
    packer_debug(&quot;Start &quot; + funcname);
    packdebug_tablevel++;
  };

  packer_debug_end = function (funcname) {
    packdebug_tablevel--;
    packer_debug(&quot;Leave &quot; + funcname);
  };
}
else {
  packer_debug = function () {
  };
  packer_debug_start = function () {
  };
  packer_debug_end = function () {
  };
}

exports.setWarningMode = (t) =&gt; {
  sintern2.setWarningMode(t);
  
  if (typeof t !== &quot;number&quot; || isNaN(t)) {
    throw new Error(&quot;Expected a single number (&gt;= 0) argument to setWarningMode&quot;);
  }

  warninglvl = t;
}

exports.setDebugMode = (t) =&gt; {
  debug_struct = t;

  sintern2.setDebugMode(t);
  
  if (debug_struct) {
    packer_debug = function (msg) {
      if (msg != undefined) {
        let t = gen_tabstr(packdebug_tablevel);
        console.log(t + msg);
      } else {
        console.log(&quot;Warning: undefined msg&quot;);
      }
    };
    packer_debug_start = function (funcname) {
      packer_debug(&quot;Start &quot; + funcname);
      packdebug_tablevel++;
    };

    packer_debug_end = function (funcname) {
      packdebug_tablevel--;
      packer_debug(&quot;Leave &quot; + funcname);
    };
  }
  else {
    packer_debug = function () {
    };
    packer_debug_start = function () {
    };
    packer_debug_end = function () {
    };
  }
}

let _ws_env = [[undefined, undefined]];

function do_pack(data, val, obj, thestruct, field, type) {
  StructFieldTypeMap[field.type.type].pack(manager, data, val, obj, field, type);
}

function define_empty_class(name) {
  let cls = function () {
  };

  cls.prototype = Object.create(Object.prototype);
  cls.constructor = cls.prototype.constructor = cls;

  cls.STRUCT = name + &quot; {\n  }\n&quot;;
  cls.structName = name;

  cls.prototype.loadSTRUCT = function (reader) {
    reader(this);
  }

  cls.newSTRUCT = function () {
    return new this();
  }

  return cls;
}

let STRUCT = exports.STRUCT = class STRUCT {
  constructor() {
    this.idgen = new struct_util.IDGen();
    this.allowOverriding = true;

    this.structs = {}
    this.struct_cls = {}
    this.struct_ids = {}

    this.compiled_code = {}
    this.null_natives = {}

    function define_null_native(name, cls) {
      let obj = define_empty_class(name);

      let stt = struct_parse.parse(obj.STRUCT);

      stt.id = this.idgen.gen_id();

      this.structs[name] = stt;
      this.struct_cls[name] = cls;
      this.struct_ids[stt.id] = stt;

      this.null_natives[name] = 1;
    }

    define_null_native.call(this, &quot;Object&quot;, Object);
  }

  validateStructs(onerror) {
    function getType(type) {
      switch (type.type) {
        case StructEnum.T_ITERKEYS:
        case StructEnum.T_ITER:
        case StructEnum.T_STATIC_ARRAY:
        case StructEnum.T_ARRAY:
          return getType(type.data.type);
        case StructEnum.T_TSTRUCT:
          return type;
        case StructEnum.T_STRUCT:
        default:
          return type;
      }
    }

    function formatType(type) {
      let ret = {};

      ret.type = type.type;

      if (typeof ret.type === &quot;number&quot;) {
        for (let k in StructEnum) {
          if (StructEnum[k] === ret.type) {
            ret.type = k;
            break;
          }
        }
      } else if (typeof ret.type === &quot;object&quot;) {
        ret.type = formatType(ret.type);
      }

      if (typeof type.data === &quot;object&quot;) {
        ret.data = formatType(type.data);
      } else {
        ret.data = type.data;
      }

      return ret;
    }

    for (let k in this.structs) {
      let stt = this.structs[k];

      for (let field of stt.fields) {
        let type = getType(field.type);

        //console.log(formatType(type));

        if (type.type !== StructEnum.T_STRUCT &amp;&amp; type.type !== StructEnum.T_TSTRUCT) {
          continue;
        }

        if (!(type.data in this.structs)) {

          let msg = stt.name + &quot;:&quot; + field.name + &quot;: Unknown struct &quot; + type.data + &quot;.&quot;;
          let buf = STRUCT.formatStruct(stt);

          console.error(buf + &quot;\n\n&quot; + msg);

          if (onerror) {
            onerror(msg, stt, field);
          } else {
            throw new Error(msg);
          }
        }
        //console.log(formatType(field.type));
      }
    }
  }

  forEach(func, thisvar) {
    for (let k in this.structs) {
      let stt = this.structs[k];

      if (thisvar !== undefined)
        func.call(thisvar, stt);
      else
        func(stt);
    }
  }

  //defined_classes is an array of class constructors
  //with STRUCT scripts, *OR* another STRUCT instance
  //
  //defaults to structjs.manager
  parse_structs(buf, defined_classes) {
    if (defined_classes === undefined) {
      defined_classes = exports.manager;
    }

    if (defined_classes instanceof STRUCT) {
      let struct2 = defined_classes;
      defined_classes = [];

      for (let k in struct2.struct_cls) {
        defined_classes.push(struct2.struct_cls[k]);
      }
    }

    if (defined_classes === undefined) {
      defined_classes = [];

      for (let k in exports.manager.struct_cls) {
        defined_classes.push(exports.manager.struct_cls[k]);
      }
    }

    let clsmap = {}

    for (let i = 0; i &lt; defined_classes.length; i++) {
      let cls = defined_classes[i];

      if (!cls.structName &amp;&amp; cls.STRUCT) {
        let stt = struct_parse.parse(cls.STRUCT.trim());
        cls.structName = stt.name;
      } else if (!cls.structName &amp;&amp; cls.name !== &quot;Object&quot;) {
        if (warninglvl &gt; 0) 
          console.log(&quot;Warning, bad class in registered class list&quot;, unmangle(cls.name), cls);
        continue;
      }

      clsmap[cls.structName] = defined_classes[i];
    }

    struct_parse.input(buf);

    while (!struct_parse.at_end()) {
      let stt = struct_parse.parse(undefined, false);

      if (!(stt.name in clsmap)) {
        if (!(stt.name in this.null_natives))
        if (warninglvl &gt; 0) 
          console.log(&quot;WARNING: struct &quot; + stt.name + &quot; is missing from class list.&quot;);

        let dummy = define_empty_class(stt.name);

        dummy.STRUCT = STRUCT.fmt_struct(stt);
        dummy.structName = stt.name;

        dummy.prototype.structName = dummy.name;

        this.struct_cls[dummy.structName] = dummy;
        this.structs[dummy.structName] = stt;

        if (stt.id !== -1)
          this.struct_ids[stt.id] = stt;
      } else {
        this.struct_cls[stt.name] = clsmap[stt.name];
        this.structs[stt.name] = stt;

        if (stt.id !== -1)
          this.struct_ids[stt.id] = stt;
      }

      let tok = struct_parse.peek();
      while (tok &amp;&amp; (tok.value === &quot;\n&quot; || tok.value === &quot;\r&quot; || tok.value === &quot;\t&quot; || tok.value === &quot; &quot;)) {
        tok = struct_parse.peek();
      }
    }
  }

  register(cls, structName) {
    return this.add_class(cls, structName);
  }

  add_class(cls, structName) {
    if (cls.STRUCT) {
      let bad = false;
      
      let p = cls;
      while (p) {
        p = p.__proto__;
        
        if (p &amp;&amp; p.STRUCT &amp;&amp; p.STRUCT === cls.STRUCT) {
          bad = true;
          break;
        }
      }
      
      if (bad) {
        console.warn(&quot;Generating STRUCT script for derived class &quot; + unmangle(cls.name));
        if (!structName) {
          structName = unmangle(cls.name);
        }
        
        cls.STRUCT = STRUCT.inherit(cls, p) + `\n}`;
      }
    }
    
    if (!cls.STRUCT) {
      throw new Error(&quot;class &quot; + unmangle(cls.name) + &quot; has no STRUCT script&quot;);
    }

    let stt = struct_parse.parse(cls.STRUCT);

    stt.name = unmangle(stt.name);

    cls.structName = stt.name;

    //create default newSTRUCT
    if (cls.newSTRUCT === undefined) {
      cls.newSTRUCT = function () {
        return new this();
      }
    }

    if (structName !== undefined) {
      stt.name = cls.structName = structName;
    } else if (cls.structName === undefined) {
      cls.structName = stt.name;
    } else {
      stt.name = cls.structName;
    }

    if (cls.structName in this.structs) {
      console.warn(&quot;Struct &quot; + unmangle(cls.structName) + &quot; is already registered&quot;, cls);

      if (!this.allowOverriding) {
        throw new Error(&quot;Struct &quot; + unmangle(cls.structName) + &quot; is already registered&quot;);
      }

      return;
    }

    if (stt.id === -1)
      stt.id = this.idgen.gen_id();

    this.structs[cls.structName] = stt;
    this.struct_cls[cls.structName] = cls;
    this.struct_ids[stt.id] = stt;
  }

  get_struct_id(id) {
    return this.struct_ids[id];
  }

  get_struct(name) {
    if (!(name in this.structs)) {
      console.trace();
      throw new Error(&quot;Unknown struct &quot; + name);
    }
    return this.structs[name];
  }

  get_struct_cls(name) {
    if (!(name in this.struct_cls)) {
      console.trace();
      throw new Error(&quot;Unknown struct &quot; + name);
    }
    return this.struct_cls[name];
  }

  static inherit(child, parent, structName = child.name) {
    if (!parent.STRUCT) {
      return structName + &quot;{\n&quot;;
    }

    let stt = struct_parse.parse(parent.STRUCT);
    let code = structName + &quot;{\n&quot;;
    code += STRUCT.fmt_struct(stt, true);
    return code;
  }

  /** invoke loadSTRUCT methods on parent objects.  note that
   reader() is only called once.  it is called however.*/
  static Super(obj, reader) {
    if (warninglvl &gt; 0) 
      console.warn(&quot;deprecated&quot;);

    reader(obj);

    function reader2(obj) {
    }

    let cls = obj.constructor;
    let bad = cls === undefined || cls.prototype === undefined || cls.prototype.__proto__ === undefined;

    if (bad) {
      return;
    }

    let parent = cls.prototype.__proto__.constructor;
    bad = bad || parent === undefined;

    if (!bad &amp;&amp; parent.prototype.loadSTRUCT &amp;&amp; parent.prototype.loadSTRUCT !== obj.loadSTRUCT) { //parent.prototype.hasOwnProperty(&quot;loadSTRUCT&quot;)) {
      parent.prototype.loadSTRUCT.call(obj, reader2);
    }
  }

  /** deprecated.  used with old fromSTRUCT interface. */
  static chain_fromSTRUCT(cls, reader) {
    if (warninglvl &gt; 0) 
      console.warn(&quot;Using deprecated (and evil) chain_fromSTRUCT method, eek!&quot;);

    let proto = cls.prototype;
    let parent = cls.prototype.prototype.constructor;

    let obj = parent.fromSTRUCT(reader);
    let obj2 = new cls();

    let keys = Object.keys(obj).concat(Object.getOwnPropertySymbols(obj));
    //let keys=Object.keys(proto);

    for (let i = 0; i &lt; keys.length; i++) {
      let k = keys[i];

      try {
        obj2[k] = obj[k];
      } catch (error) {
        if (warninglvl &gt; 0) 
          console.warn(&quot;  failed to set property&quot;, k);
      }
      //let k=keys[i];
      //if (k==&quot;__proto__&quot;)
      // continue;
      //obj[k] = proto[k];
    }

    /*
    if (proto.toString !== Object.prototype.toString)
      obj2.toString = proto.toString;
    //*/

    return obj2;
  }

  static formatStruct(stt, internal_only, no_helper_js) {
    return this.fmt_struct(stt, internal_only, no_helper_js);
  }

  static fmt_struct(stt, internal_only, no_helper_js) {
    if (internal_only == undefined)
      internal_only = false;
    if (no_helper_js == undefined)
      no_helper_js = false;

    let s = &quot;&quot;;
    if (!internal_only) {
      s += stt.name;
      if (stt.id != -1)
        s += &quot; id=&quot; + stt.id;
      s += &quot; {\n&quot;;
    }
    let tab = &quot;  &quot;;

    function fmt_type(type) {
      return StructFieldTypeMap[type.type].format(type);
      
      if (type.type === StructEnum.T_ARRAY || type.type === StructEnum.T_ITER || type.type === StructEnum.T_ITERKEYS) {
        if (type.data.iname !== &quot;&quot; &amp;&amp; type.data.iname !== undefined) {
          return &quot;array(&quot; + type.data.iname + &quot;, &quot; + fmt_type(type.data.type) + &quot;)&quot;;
        }
        else {
          return &quot;array(&quot; + fmt_type(type.data.type) + &quot;)&quot;;
        }
      } else if (type.type === StructEnum.T_STATIC_STRING) {
        return &quot;static_string[&quot; + type.data.maxlength + &quot;]&quot;;
      } else if (type.type === StructEnum.T_STRUCT) {
        return type.data;
      } else if (type.type === StructEnum.T_TSTRUCT) {
        return &quot;abstract(&quot; + type.data + &quot;)&quot;;
      } else {
        return StructTypeMap[type.type];
      }
    }

    let fields = stt.fields;
    for (let i = 0; i &lt; fields.length; i++) {
      let f = fields[i];
      s += tab + f.name + &quot; : &quot; + fmt_type(f.type);
      if (!no_helper_js &amp;&amp; f.get != undefined) {
        s += &quot; | &quot; + f.get.trim();
      }
      s += &quot;;\n&quot;;
    }
    if (!internal_only)
      s += &quot;}&quot;;
    return s;
  }

  _env_call(code, obj, env) {
    let envcode = _static_envcode_null;
    if (env !== undefined) {
      envcode = &quot;&quot;;
      for (let i = 0; i &lt; env.length; i++) {
        envcode = &quot;var &quot; + env[i][0] + &quot; = env[&quot; + i.toString() + &quot;][1];\n&quot; + envcode;
      }
    }
    let fullcode = &quot;&quot;;
    if (envcode !== _static_envcode_null)
      fullcode = envcode + code;
    else
      fullcode = code;
    let func;

    //fullcode = fullcode.replace(/\bthis\b/, &quot;obj&quot;);

    if (!(fullcode in this.compiled_code)) {
      let code2 = &quot;func = function(obj, env) { &quot; + envcode + &quot;return &quot; + code + &quot;}&quot;;
      try {
        func = _structEval(code2);
      }
      catch (err) {
        struct_util.print_stack(err);

        console.log(code2);
        console.log(&quot; &quot;);
        throw err;
      }
      this.compiled_code[fullcode] = func;
    }
    else {
      func = this.compiled_code[fullcode];
    }
    try {
      return func.call(obj, obj, env);
    }
    catch (err) {
      struct_util.print_stack(err);

      let code2 = &quot;func = function(obj, env) { &quot; + envcode + &quot;return &quot; + code + &quot;}&quot;;
      console.log(code2);
      console.log(&quot; &quot;);
      throw err;
    }
  }

  write_struct(data, obj, stt) {
    function use_helper_js(field) {
      let type = field.type.type;
      let cls = StructFieldTypeMap[type];
      return cls.useHelperJS(field);
    }

    var fields = stt.fields;
    var thestruct = this;
    for (var i = 0; i &lt; fields.length; i++) {
      var f = fields[i];
      var t1 = f.type;
      var t2 = t1.type;

      if (use_helper_js(f)) {
        var val;
        var type = t2;
        if (f.get != undefined) {
          val = thestruct._env_call(f.get, obj);
        }
        else {
          val = obj[f.name];
        }
        
        if (_nGlobal.DEBUG &amp;&amp; _nGlobal.DEBUG.tinyeval) { 
          console.log(&quot;\n\n\n&quot;, f.get, &quot;Helper JS Ret&quot;, val, &quot;\n\n\n&quot;);
        }

        do_pack(data, val, obj, thestruct, f, t1);
      }
      else {
        var val = obj[f.name];
        do_pack(data, val, obj, thestruct, f, t1);
      }
    }
  }

  /**
  @param data : array to write data into,
  @param obj  : structable object
  */
  write_object(data, obj) {
    var cls = obj.constructor.structName;
    var stt = this.get_struct(cls);

    if (data === undefined) {
      data = [];
    }

    this.write_struct(data, obj, stt);
    return data;
  }

  /**
  Read an object from binary data
  
  @param data : DataView or Uint8Array instance
  @param cls_or_struct_id : Structable class
  @param uctx : internal parameter
  @return {cls_or_struct_id} Instance of cls_or_struct_id
  */
  readObject(data, cls_or_struct_id, uctx) {
    return this.read_object(data, cls_or_struct_id, uctx);
  }
  
  /**
  @param data array to write data into,
  @param obj structable object
  */
  writeObject(data, obj) {
    return this.write_object(data, obj);
  }

  writeJSON(obj, stt=undefined) {
    var cls = obj.constructor.structName;
    stt = stt || this.get_struct(cls);

    function use_helper_js(field) {
      let type = field.type.type;
      let cls = StructFieldTypeMap[type];
      return cls.useHelperJS(field);
    }

    let toJSON = sintern2.toJSON;

    var fields = stt.fields;
    var thestruct = this;
    let json = {};

    for (var i = 0; i &lt; fields.length; i++) {
      var f = fields[i];
      var t1 = f.type;
      var t2 = t1.type;
      var val;

      if (use_helper_js(f)) {
        var type = t2;
        if (f.get !== undefined) {
          val = thestruct._env_call(f.get, obj);
        }
        else {
          val = obj[f.name];
        }

        if (_nGlobal.DEBUG &amp;&amp; _nGlobal.DEBUG.tinyeval) {
          console.log(&quot;\n\n\n&quot;, f.get, &quot;Helper JS Ret&quot;, val, &quot;\n\n\n&quot;);
        }

        json[f.name] = toJSON(this, val, obj, f, t1);
      }
      else {
        val = obj[f.name];
        json[f.name] = toJSON(this, val, obj, f, t1);
      }
    }

    return json;
  }

  /**
  @param data : DataView or Uint8Array instance
  @param cls_or_struct_id : Structable class
  @param uctx : internal parameter
  */
  read_object(data, cls_or_struct_id, uctx) {
    let cls, stt;

    if (data instanceof Array) {
      data = new DataView(new Uint8Array(data).buffer);
    }

    if (typeof cls_or_struct_id == &quot;number&quot;) {
      cls = this.struct_cls[this.struct_ids[cls_or_struct_id].name];
    } else {
      cls = cls_or_struct_id;
    }

    if (cls === undefined) {
      throw new Error(&quot;bad cls_or_struct_id &quot; + cls_or_struct_id);
    }

    stt = this.structs[cls.structName];

    if (uctx == undefined) {
      uctx = new struct_binpack.unpack_context();

      packer_debug(&quot;\n\n=Begin reading &quot; + cls.structName + &quot;=&quot;);
    }
    let thestruct = this;

    let this2  = this;
    function unpack_field(type) {
      return StructFieldTypeMap[type.type].unpack(this2, data, type, uctx);
    }

    let was_run = false;

    function load(obj) {
      if (was_run) {
        return;
      }

      was_run = true;

      let fields = stt.fields;
      let flen = fields.length;
      for (let i = 0; i &lt; flen; i++) {
        let f = fields[i];
        let val = unpack_field(f.type);
        obj[f.name] = val;
      }
    }

    if (cls.prototype.loadSTRUCT !== undefined) {
      let obj;

      if (cls.newSTRUCT !== undefined) {
        obj = cls.newSTRUCT();
      } else {
        obj = new cls();
      }

      obj.loadSTRUCT(load);
      return obj;
    } else if (cls.fromSTRUCT !== undefined) {
      if (warninglvl &gt; 1) 
        console.warn(&quot;Warning: class &quot; + unmangle(cls.name) + &quot; is using deprecated fromSTRUCT interface; use newSTRUCT/loadSTRUCT instead&quot;);
      return cls.fromSTRUCT(load);
    } else { //default case, make new instance and then call load() on it
      let obj;
      if (cls.newSTRUCT !== undefined) {
        obj = cls.newSTRUCT();
      } else {
        obj = new cls();
      }

      load(obj);

      return obj;
    }
  }

  readJSON(data, cls_or_struct_id) {
    let cls, stt;

    if (typeof cls_or_struct_id === &quot;number&quot;) {
      cls = this.struct_cls[this.struct_ids[cls_or_struct_id].name];
    } else {
      cls = cls_or_struct_id;
    }

    if (cls === undefined) {
      throw new Error(&quot;bad cls_or_struct_id &quot; + cls_or_struct_id);
    }

    stt = this.structs[cls.structName];

    let fromJSON = sintern2.fromJSON;
    let thestruct = this;

    let this2  = this;

    let was_run = false;

    function reader(obj) {
      if (was_run) {
        return;
      }

      was_run = true;

      let fields = stt.fields;
      let flen = fields.length;
      for (let i = 0; i &lt; flen; i++) {
        let f = fields[i];

        packer_debug(&quot;Load field &quot; + f.name);
        obj[f.name] = fromJSON(thestruct, data[f.name], data, f.type);
      }
    }

    if (cls.prototype.loadSTRUCT !== undefined) {
      let obj;

      if (cls.newSTRUCT !== undefined) {
        obj = cls.newSTRUCT();
      } else {
        obj = new cls();
      }

      obj.loadSTRUCT(reader);

      return obj;
    } else if (cls.fromSTRUCT !== undefined) {
      if (warninglvl &gt; 1)
        console.warn(&quot;Warning: class &quot; + unmangle(cls.name) + &quot; is using deprecated fromSTRUCT interface; use newSTRUCT/loadSTRUCT instead&quot;);

      return cls.fromSTRUCT(reader);
    } else { //default case, make new instance and then call reader() on it
      let obj;
      if (cls.newSTRUCT !== undefined) {
        obj = cls.newSTRUCT();
      } else {
        obj = new cls();
      }

      reader(obj);

      return obj;
    }
  }
}

//main struct script manager
let manager = exports.manager = new STRUCT();

/**
 * Write all defined structs out to a string.
 *
 * @param manager STRUCT instance, defaults to nstructjs.manager
 * @param include_code include save code snippets
 * */
let write_scripts = exports.write_scripts = function write_scripts(manager, include_code = false) {
  if (manager === undefined)
    manager = exports.manager;

  let buf = &quot;&quot;;

  manager.forEach(function (stt) {
    buf += STRUCT.fmt_struct(stt, false, !include_code) + &quot;\n&quot;;
  });

  let buf2 = buf;
  buf = &quot;&quot;;

  for (let i = 0; i &lt; buf2.length; i++) {
    let c = buf2[i];
    if (c === &quot;\n&quot;) {
      buf += &quot;\n&quot;;
      let i2 = i;
      while (i &lt; buf2.length &amp;&amp; (buf2[i] === &quot; &quot; || buf2[i] === &quot;\t&quot; || buf2[i] === &quot;\n&quot;)) {
        i++;
      }
      if (i !== i2)
        i--;
    }
    else {
      buf += c;
    }
  }

  return buf;
}
</code></pre>

</div>

<footer class="footer">
  Generated by <a href="https://esdoc.org">ESDoc<span data-ice="esdocVersion">(1.1.0)</span><img src="./image/esdoc-logo-mini-black.png"></a>
</footer>

<script src="script/search_index.js"></script>
<script src="script/search.js"></script>
<script src="script/pretty-print.js"></script>
<script src="script/inherited-summary.js"></script>
<script src="script/test-summary.js"></script>
<script src="script/inner-link.js"></script>
<script src="script/patch-for-local.js"></script>
</body>
</html>
