<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <base data-ice="baseUrl" href="../../">
  <title data-ice="title">src/struct_intern.js | nstructjs</title>
  <link type="text/css" rel="stylesheet" href="css/style.css">
  <link type="text/css" rel="stylesheet" href="css/prettify-tomorrow.css">
  <script src="script/prettify/prettify.js"></script>
  <script src="script/manual.js"></script>
<meta name="description" content="ProtoBuf-like serialization system optimized for JS"><meta property="twitter:card" content="summary"><meta property="twitter:title" content="nstructjs"><meta property="twitter:description" content="ProtoBuf-like serialization system optimized for JS"></head>
<body class="layout-container" data-ice="rootContainer">

<header>
  <a href="./">Home</a>
  <a href="./manual/index.html" data-ice="manualHeaderLink">Manual</a>
  <a href="identifiers.html">Reference</a>
  <a href="source.html">Source</a>
  
  <div class="search-box">
  <span>
    <img src="./image/search.png">
    <span class="search-input-edge"></span><input class="search-input"><span class="search-input-edge"></span>
  </span>
    <ul class="search-result"></ul>
  </div>
</header>

<nav class="navigation" data-ice="nav"><div>
  <ul>
    
  <li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/struct_filehelper.js~Block.html">Block</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/struct_filehelper.js~FileError.html">FileError</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/struct_filehelper.js~FileHelper.html">FileHelper</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/struct_filehelper.js~FileParams.html">FileParams</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/struct_intern.js~STRUCT.html">STRUCT</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/struct_parseutil.js~PUTIL_ParseError.html">PUTIL_ParseError</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/struct_parseutil.js~lexer.html">lexer</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/struct_parseutil.js~parser.html">parser</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/struct_parseutil.js~tokdef.html">tokdef</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/struct_parseutil.js~token.html">token</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-decode_utf8">decode_utf8</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-encode_utf8">encode_utf8</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-pack_byte">pack_byte</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-pack_bytes">pack_bytes</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-pack_double">pack_double</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-pack_float">pack_float</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-pack_int">pack_int</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-pack_short">pack_short</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-pack_static_string">pack_static_string</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-pack_string">pack_string</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-test_utf8">test_utf8</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-unpack_byte">unpack_byte</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-unpack_bytes">unpack_bytes</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-unpack_double">unpack_double</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-unpack_float">unpack_float</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-unpack_int">unpack_int</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-unpack_short">unpack_short</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-unpack_static_string">unpack_static_string</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-unpack_string">unpack_string</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-versionCoerce">versionCoerce</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-versionLessThan">versionLessThan</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-versionToInt">versionToInt</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-write_scripts">write_scripts</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-Class">Class</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-get_callstack">get_callstack</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-is_obj_lit">is_obj_lit</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-print_stack">print_stack</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-inherit">inherit</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-register">register</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-useTinyEval">useTinyEval</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-StructEnum">StructEnum</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-StructTypeMap">StructTypeMap</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-StructTypes">StructTypes</a></span></span></li>
</ul>
</div>
</nav>

<div class="content" data-ice="content"><h1 data-ice="title">src/struct_intern.js</h1>
<pre class="source-code line-number raw-source-code"><code class="prettyprint linenums" data-ice="content">&quot;use strict&quot;;
let struct_util = require(&quot;./struct_util&quot;);
let struct_binpack = require(&quot;./struct_binpack&quot;);
let struct_parseutil = require(&quot;./struct_parseutil&quot;);
let struct_typesystem = require(&quot;./struct_typesystem&quot;);
let struct_parser = require(&quot;./struct_parser&quot;);

let warninglvl = 2;

/*

class SomeClass {
  static newSTRUCT() {
    //returns a new, empty instance of SomeClass
  }
  
  loadSTRUCT(reader) {
    reader(this); //reads data into this instance
  }
  
  //the old api, that both creates and reads
  static fromSTRUCT(reader) {
    let ret = new SomeClass();
    reader(ret);
    return ret;
  }
}
SomeClass.STRUCT = `
SomeClass {
}
`
nstructjs.manager.add_class(SomeClass);

*/
var StructTypeMap = struct_parser.StructTypeMap;
var StructTypes = struct_parser.StructTypes;
var Class = struct_typesystem.Class;

var struct_parse = struct_parser.struct_parse;
var StructEnum = struct_parser.StructEnum;

var _static_envcode_null = &quot;&quot;;
var debug_struct = 0;
var packdebug_tablevel = 0;

function gen_tabstr(tot) {
  var ret = &quot;&quot;;

  for (var i = 0; i &lt; tot; i++) {
    ret += &quot; &quot;;
  }

  return ret;
}

let packer_debug, packer_debug_start, packer_debug_end;

if (debug_struct) {
  packer_debug = function (msg) {
    if (msg !== undefined) {
      var t = gen_tabstr(packdebug_tablevel);
      console.log(t + msg);
    } else {
      console.log(&quot;Warning: undefined msg&quot;);
    }
  };
  packer_debug_start = function (funcname) {
    packer_debug(&quot;Start &quot; + funcname);
    packdebug_tablevel++;
  };

  packer_debug_end = function (funcname) {
    packdebug_tablevel--;
    packer_debug(&quot;Leave &quot; + funcname);
  };
}
else {
  packer_debug = function () {
  };
  packer_debug_start = function () {
  };
  packer_debug_end = function () {
  };
}


exports.setWarningMode = (t) =&gt; {
  if (typeof t !== &quot;number&quot; || isNaN(t)) {
    throw new Error(&quot;Expected a single number (&gt;= 0) argument to setWarningMode&quot;);
  }

  warninglvl = t;
}

exports.setDebugMode = (t) =&gt; {
  debug_struct = t;

  if (debug_struct) {
    packer_debug = function (msg) {
      if (msg != undefined) {
        var t = gen_tabstr(packdebug_tablevel);
        console.log(t + msg);
      } else {
        console.log(&quot;Warning: undefined msg&quot;);
      }
    };
    packer_debug_start = function (funcname) {
      packer_debug(&quot;Start &quot; + funcname);
      packdebug_tablevel++;
    };

    packer_debug_end = function (funcname) {
      packdebug_tablevel--;
      packer_debug(&quot;Leave &quot; + funcname);
    };
  }
  else {
    packer_debug = function () {
    };
    packer_debug_start = function () {
    };
    packer_debug_end = function () {
    };
  }
}

var _ws_env = [[undefined, undefined]];
var pack_callbacks = [
  function pack_int(data, val) {
    packer_debug(&quot;int &quot; + val);

    struct_binpack.pack_int(data, val);
  }, function pack_float(data, val) {
    packer_debug(&quot;float &quot; + val);

    struct_binpack.pack_float(data, val);
  }, function pack_double(data, val) {
    packer_debug(&quot;double &quot; + val);

    struct_binpack.pack_double(data, val);
  }, 0, 0, 0, 0,
  function pack_string(data, val) {
    if (val == undefined)
      val = &quot;&quot;;
    packer_debug(&quot;string: &quot; + val);
    packer_debug(&quot;int &quot; + val.length);

    struct_binpack.pack_string(data, val);
  }, function pack_static_string(data, val, obj, thestruct, field, type) {
    if (val == undefined)
      val = &quot;&quot;;
    packer_debug(&quot;static_string: &apos;&quot; + val + &quot;&apos; length=&quot; + type.data.maxlength);

    struct_binpack.pack_static_string(data, val, type.data.maxlength);
  }, function pack_struct(data, val, obj, thestruct, field, type) {
    packer_debug_start(&quot;struct &quot; + type.data);

    thestruct.write_struct(data, val, thestruct.get_struct(type.data));

    packer_debug_end(&quot;struct&quot;);
  }, function pack_tstruct(data, val, obj, thestruct, field, type) {
    var cls = thestruct.get_struct_cls(type.data);
    var stt = thestruct.get_struct(type.data);

    //make sure inheritance is correct
    if (val.constructor.structName != type.data &amp;&amp; (val instanceof cls)) {
      //if (DEBUG.Struct) {
      //    console.log(val.constructor.structName+&quot; inherits from &quot;+cls.structName);
      //}
      stt = thestruct.get_struct(val.constructor.structName);
    } else if (val.constructor.structName == type.data) {
      stt = thestruct.get_struct(type.data);
    } else {
      console.trace();
      throw new Error(&quot;Bad struct &quot; + val.constructor.structName + &quot; passed to write_struct&quot;);
    }

    if (stt.id == 0) {
    }

    packer_debug_start(&quot;tstruct &apos;&quot; + stt.name + &quot;&apos;&quot;);
    packer_debug(&quot;int &quot; + stt.id);

    struct_binpack.pack_int(data, stt.id);
    thestruct.write_struct(data, val, stt);

    packer_debug_end(&quot;tstruct&quot;);
  }, function pack_array(data, val, obj, thestruct, field, type) {
    packer_debug_start(&quot;array&quot;);

    if (val == undefined) {
      console.trace();
      console.log(&quot;Undefined array fed to struct struct packer!&quot;);
      console.log(&quot;Field: &quot;, field);
      console.log(&quot;Type: &quot;, type);
      console.log(&quot;&quot;);
      packer_debug(&quot;int 0&quot;);
      struct_binpack.pack_int(data, 0);
      return;
    }

    packer_debug(&quot;int &quot; + val.length);
    struct_binpack.pack_int(data, val.length);

    var d = type.data;

    var itername = d.iname;
    var type2 = d.type;

    var env = _ws_env;
    for (var i = 0; i &lt; val.length; i++) {
      var val2 = val[i];
      if (itername != &quot;&quot; &amp;&amp; itername != undefined &amp;&amp; field.get) {
        env[0][0] = itername;
        env[0][1] = val2;
        val2 = thestruct._env_call(field.get, obj, env);
      }
      var f2 = {type: type2, get: undefined, set: undefined};
      do_pack(data, val2, obj, thestruct, f2, type2);
    }
    packer_debug_end(&quot;array&quot;);
  }, function pack_iter(data, val, obj, thestruct, field, type) {
    //this was originally implemented to use ES6 iterators.

    packer_debug_start(&quot;iter&quot;);
    
    function forEach(cb, thisvar) {
      if (val &amp;&amp; val[Symbol.iterator]) {
        for (let item of val) {
          cb.call(thisvar, item);
        }
      } else if (val &amp;&amp; val.forEach) {
        val.forEach(function(item) {
          cb.call(thisvar, item);
        });
      } else {
        console.trace();
        console.log(&quot;Undefined iterable list fed to struct struct packer!&quot;, val);
        console.log(&quot;Field: &quot;, field);
        console.log(&quot;Type: &quot;, type);
        console.log(&quot;&quot;);
      }
    }
    
    let len = 0.0;
    forEach(() =&gt; {
      len++;
    });

    packer_debug(&quot;int &quot; + len);
    struct_binpack.pack_int(data, len);

    var d = type.data, itername = d.iname, type2 = d.type;
    var env = _ws_env;

    var i = 0;
    forEach(function(val2) {
      if (i &gt;= len) {
        if (warninglvl &gt; 0) 
          console.trace(&quot;Warning: iterator returned different length of list!&quot;, val, i);
        return;
      }

      if (itername != &quot;&quot; &amp;&amp; itername != undefined &amp;&amp; field.get) {
        env[0][0] = itername;
        env[0][1] = val2;
        val2 = thestruct._env_call(field.get, obj, env);
      }

      var f2 = {type: type2, get: undefined, set: undefined};
      do_pack(data, val2, obj, thestruct, f2, type2);

      i++;
    }, this);

    packer_debug_end(&quot;iter&quot;);
  }, function pack_short(data, val) {
    packer_debug(&quot;short &quot; + val);

    struct_binpack.pack_short(data, Math.floor(val));
  }, function pack_byte(data, val) {
    packer_debug(&quot;byte &quot; + val);

    struct_binpack.pack_byte(data, Math.floor(val));
  }, function pack_bool(data, val) {
    packer_debug(&quot;bool &quot; + val);

    struct_binpack.pack_byte(data, !!val);
  },function pack_iterkeys(data, val, obj, thestruct, field, type) {
    //this was originally implemented to use ES6 iterators.

    packer_debug_start(&quot;iterkeys&quot;);
    
    if ((typeof val !== &quot;object&quot; &amp;&amp; typeof val !== &quot;function&quot;) || val === null) {
        console.warn(&quot;Bad object fed to iterkeys in struct packer!&quot;, val);
        console.log(&quot;Field: &quot;, field);
        console.log(&quot;Type: &quot;, type);
        console.log(&quot;&quot;);
        
        struct_binpack.pack_int(data, 0);
        
        packer_debug_end(&quot;iterkeys&quot;);
        return;
    }
    
    let len = 0.0;
    for (let k in val) {
      len++;
    }
    
    packer_debug(&quot;int &quot; + len);
    struct_binpack.pack_int(data, len);

    var d = type.data, itername = d.iname, type2 = d.type;
    var env = _ws_env;

    var i = 0;
    for (let val2 in val) {
      if (i &gt;= len) {
        if (warninglvl &gt; 0) 
          console.warn(&quot;Warning: object keys magically changed on us&quot;, val, i);
        return;
      }

      if (itername &amp;&amp; itername.trim().length &gt; 0 &amp;&amp; field.get) {
        env[0][0] = itername;
        env[0][1] = val2;
        val2 = thestruct._env_call(field.get, obj, env);
      } else {
        val2 = val[val2]; //fetch value
      }

      var f2 = {type: type2, get: undefined, set: undefined};
      do_pack(data, val2, obj, thestruct, f2, type2);

      i++;
    }
    packer_debug_end(&quot;iterkeys&quot;);
  }];

function do_pack(data, val, obj, thestruct, field, type) {
  pack_callbacks[field.type.type](data, val, obj, thestruct, field, type);

}

function define_empty_class(name) {
  var cls = function () {
  };

  cls.prototype = Object.create(Object.prototype);
  cls.constructor = cls.prototype.constructor = cls;

  cls.STRUCT = name + &quot; {\n  }\n&quot;;
  cls.structName = name;

  cls.prototype.loadSTRUCT = function (reader) {
    reader(this);
  }

  cls.newSTRUCT = function () {
    return new this();
  }

  return cls;
}

var STRUCT = exports.STRUCT = class STRUCT {
  constructor() {
    this.idgen = new struct_util.IDGen();

    this.structs = {}
    this.struct_cls = {}
    this.struct_ids = {}

    this.compiled_code = {}
    this.null_natives = {}

    function define_null_native(name, cls) {
      var obj = define_empty_class(name);

      var stt = struct_parse.parse(obj.STRUCT);

      stt.id = this.idgen.gen_id();

      this.structs[name] = stt;
      this.struct_cls[name] = cls;
      this.struct_ids[stt.id] = stt;

      this.null_natives[name] = 1;
    }

    define_null_native.call(this, &quot;Object&quot;, Object);
  }

  forEach(func, thisvar) {
    for (var k in this.structs) {
      var stt = this.structs[k];

      if (thisvar != undefined)
        func.call(thisvar, stt);
      else
        func(stt);
    }
  }

  //defined_classes is an array of class constructors
  //with STRUCT scripts, *OR* another STRUCT instance
  //
  //defaults to structjs.manager
  parse_structs(buf, defined_classes) {
    if (defined_classes === undefined) {
      defined_classes = exports.manager;
    }

    if (defined_classes instanceof STRUCT) {
      var struct2 = defined_classes;
      defined_classes = [];

      for (var k in struct2.struct_cls) {
        defined_classes.push(struct2.struct_cls[k]);
      }
    }

    if (defined_classes == undefined) {
      defined_classes = [];
      for (var k in exports.manager.struct_cls) {
        defined_classes.push(exports.manager.struct_cls[k]);
      }
    }

    var clsmap = {}

    for (var i = 0; i &lt; defined_classes.length; i++) {
      var cls = defined_classes[i];

      if (cls.structName == undefined &amp;&amp; cls.STRUCT != undefined) {
        var stt = struct_parse.parse(cls.STRUCT.trim());
        cls.structName = stt.name;
      } else if (cls.structName == undefined &amp;&amp; cls.name != &quot;Object&quot;) {
        if (warninglvl &gt; 0) 
          console.log(&quot;Warning, bad class in registered class list&quot;, cls.name, cls);
        continue;
      }

      clsmap[cls.structName] = defined_classes[i];
    }

    struct_parse.input(buf);

    while (!struct_parse.at_end()) {
      var stt = struct_parse.parse(undefined, false);

      if (!(stt.name in clsmap)) {
        if (!(stt.name in this.null_natives))
        if (warninglvl &gt; 0) 
          console.log(&quot;WARNING: struct &quot; + stt.name + &quot; is missing from class list.&quot;);

        var dummy = define_empty_class(stt.name);

        dummy.STRUCT = STRUCT.fmt_struct(stt);
        dummy.structName = stt.name;

        dummy.prototype.structName = dummy.name;

        this.struct_cls[dummy.structName] = dummy;
        this.structs[dummy.structName] = stt;

        if (stt.id != -1)
          this.struct_ids[stt.id] = stt;
      } else {
        this.struct_cls[stt.name] = clsmap[stt.name];
        this.structs[stt.name] = stt;

        if (stt.id != -1)
          this.struct_ids[stt.id] = stt;
      }

      var tok = struct_parse.peek();
      while (tok != undefined &amp;&amp; (tok.value == &quot;\n&quot; || tok.value == &quot;\r&quot; || tok.value == &quot;\t&quot; || tok.value == &quot; &quot;)) {
        tok = struct_parse.peek();
      }
    }
  }

  register(cls, structName) {
    return this.add_class(cls, structName);
  }

  add_class(cls, structName) {
    if (cls.STRUCT) {
      let bad = false;
      
      let p = cls;
      while (p) {
        p = p.__proto__;
        
        if (p &amp;&amp; p.STRUCT &amp;&amp; p.STRUCT === cls.STRUCT) {
          bad = true;
          break;
        }
      }
      
      if (bad) {
        console.warn(&quot;Generating STRUCT script for derived class &quot; + cls.name);
        if (!structName) {
          structName = cls.name;
        }
        
        cls.STRUCT = STRUCT.inherit(cls, p) + `\n}`;
      }
    }
    
    if (!cls.STRUCT) {
      throw new Error(&quot;class &quot; + cls.name + &quot; has no STRUCT script&quot;);
    }

    var stt = struct_parse.parse(cls.STRUCT);

    cls.structName = stt.name;

    //create default newSTRUCT
    if (cls.newSTRUCT === undefined) {
      cls.newSTRUCT = function () {
        return new this();
      }
    }

    if (structName !== undefined) {
      stt.name = cls.structName = structName;
    } else if (cls.structName === undefined) {
      cls.structName = stt.name;
    } else if (cls.structName !== undefined) {
      stt.name = cls.structName;
    } else {
      throw new Error(&quot;Missing structName parameter&quot;);
    }

    if (stt.id == -1)
      stt.id = this.idgen.gen_id();

    this.structs[cls.structName] = stt;
    this.struct_cls[cls.structName] = cls;
    this.struct_ids[stt.id] = stt;
  }

  get_struct_id(id) {
    return this.struct_ids[id];
  }

  get_struct(name) {
    if (!(name in this.structs)) {
      console.trace();
      throw new Error(&quot;Unknown struct &quot; + name);
    }
    return this.structs[name];
  }

  get_struct_cls(name) {
    if (!(name in this.struct_cls)) {
      console.trace();
      throw new Error(&quot;Unknown struct &quot; + name);
    }
    return this.struct_cls[name];
  }

  static inherit(child, parent, structName = child.name) {
    if (!parent.STRUCT) {
      return structName + &quot;{\n&quot;;
    }

    var stt = struct_parse.parse(parent.STRUCT);
    var code = structName + &quot;{\n&quot;;
    code += STRUCT.fmt_struct(stt, true);
    return code;
  }

  /** invoke loadSTRUCT methods on parent objects.  note that
   reader() is only called once.  it is called however.*/
  static Super(obj, reader) {
    if (warninglvl &gt; 0) 
      console.warn(&quot;deprecated&quot;);

    reader(obj);

    function reader2(obj) {
    }

    let cls = obj.constructor;
    let bad = cls === undefined || cls.prototype === undefined || cls.prototype.__proto__ === undefined;

    if (bad) {
      return;
    }

    let parent = cls.prototype.__proto__.constructor;
    bad = bad || parent === undefined;

    if (!bad &amp;&amp; parent.prototype.loadSTRUCT &amp;&amp; parent.prototype.loadSTRUCT !== obj.loadSTRUCT) { //parent.prototype.hasOwnProperty(&quot;loadSTRUCT&quot;)) {
      parent.prototype.loadSTRUCT.call(obj, reader2);
    }
  }

  /** deprecated.  used with old fromSTRUCT interface. */
  static chain_fromSTRUCT(cls, reader) {
    if (warninglvl &gt; 0) 
      console.warn(&quot;Using deprecated (and evil) chain_fromSTRUCT method, eek!&quot;);

    var proto = cls.prototype;
    var parent = cls.prototype.prototype.constructor;

    var obj = parent.fromSTRUCT(reader);
    let obj2 = new cls();

    let keys = Object.keys(obj).concat(Object.getOwnPropertySymbols(obj));
    //var keys=Object.keys(proto);

    for (var i = 0; i &lt; keys.length; i++) {
      let k = keys[i];

      try {
        obj2[k] = obj[k];
      } catch (error) {
        if (warninglvl &gt; 0) 
          console.warn(&quot;  failed to set property&quot;, k);
      }
      //var k=keys[i];
      //if (k==&quot;__proto__&quot;)
      // continue;
      //obj[k] = proto[k];
    }

    /*
    if (proto.toString !== Object.prototype.toString)
      obj2.toString = proto.toString;
    //*/

    return obj2;
  }

  static formatStruct(stt, internal_only, no_helper_js) {
    return this.fmt_struct(stt, internal_only, no_helper_js);
  }

  static fmt_struct(stt, internal_only, no_helper_js) {
    if (internal_only == undefined)
      internal_only = false;
    if (no_helper_js == undefined)
      no_helper_js = false;

    var s = &quot;&quot;;
    if (!internal_only) {
      s += stt.name;
      if (stt.id != -1)
        s += &quot; id=&quot; + stt.id;
      s += &quot; {\n&quot;;
    }
    var tab = &quot;  &quot;;

    function fmt_type(type) {
      if (type.type == StructEnum.T_ARRAY || type.type == StructEnum.T_ITER || type.type === StructEnum.T_ITERKEYS) {
        if (type.data.iname != &quot;&quot; &amp;&amp; type.data.iname != undefined) {
          return &quot;array(&quot; + type.data.iname + &quot;, &quot; + fmt_type(type.data.type) + &quot;)&quot;;
        }
        else {
          return &quot;array(&quot; + fmt_type(type.data.type) + &quot;)&quot;;
        }
      } else if (type.type == StructEnum.T_STATIC_STRING) {
        return &quot;static_string[&quot; + type.data.maxlength + &quot;]&quot;;
      } else if (type.type == StructEnum.T_STRUCT) {
        return type.data;
      } else if (type.type == StructEnum.T_TSTRUCT) {
        return &quot;abstract(&quot; + type.data + &quot;)&quot;;
      } else {
        return StructTypeMap[type.type];
      }
    }

    var fields = stt.fields;
    for (var i = 0; i &lt; fields.length; i++) {
      var f = fields[i];
      s += tab + f.name + &quot; : &quot; + fmt_type(f.type);
      if (!no_helper_js &amp;&amp; f.get != undefined) {
        s += &quot; | &quot; + f.get.trim();
      }
      s += &quot;;\n&quot;;
    }
    if (!internal_only)
      s += &quot;}&quot;;
    return s;
  }

  _env_call(code, obj, env) {
    var envcode = _static_envcode_null;
    if (env != undefined) {
      envcode = &quot;&quot;;
      for (var i = 0; i &lt; env.length; i++) {
        envcode = &quot;var &quot; + env[i][0] + &quot; = env[&quot; + i.toString() + &quot;][1];\n&quot; + envcode;
      }
    }
    var fullcode = &quot;&quot;;
    if (envcode !== _static_envcode_null)
      fullcode = envcode + code;
    else
      fullcode = code;
    var func;

    //fullcode = fullcode.replace(/\bthis\b/, &quot;obj&quot;);

    if (!(fullcode in this.compiled_code)) {
      var code2 = &quot;func = function(obj, env) { &quot; + envcode + &quot;return &quot; + code + &quot;}&quot;;
      try {
        func = _structEval(code2);
      }
      catch (err) {
        struct_util.print_stack(err);

        console.log(code2);
        console.log(&quot; &quot;);
        throw err;
      }
      this.compiled_code[fullcode] = func;
    }
    else {
      func = this.compiled_code[fullcode];
    }
    try {
      return func.call(obj, obj, env);
    }
    catch (err) {
      struct_util.print_stack(err);

      var code2 = &quot;func = function(obj, env) { &quot; + envcode + &quot;return &quot; + code + &quot;}&quot;;
      console.log(code2);
      console.log(&quot; &quot;);
      throw err;
    }
  }

  write_struct(data, obj, stt) {
    function use_helper_js(field) {
      if (field.type.type == StructEnum.T_ARRAY || field.type.type == StructEnum.T_ITER || field.type.type == StructEnum.T_ITERKEYS) {
        return field.type.data.iname == undefined || field.type.data.iname == &quot;&quot;;
      }
      return true;
    }

    var fields = stt.fields;
    var thestruct = this;
    for (var i = 0; i &lt; fields.length; i++) {
      var f = fields[i];
      var t1 = f.type;
      var t2 = t1.type;

      if (use_helper_js(f)) {
        var val;
        var type = t2;
        if (f.get != undefined) {
          val = thestruct._env_call(f.get, obj);
        }
        else {
          val = obj[f.name];
        }
        do_pack(data, val, obj, thestruct, f, t1);
      }
      else {
        var val = obj[f.name];
        do_pack(data, val, obj, thestruct, f, t1);
      }
    }
  }

  write_object(data, obj) {
    var cls = obj.constructor.structName;
    var stt = this.get_struct(cls);

    if (data === undefined) {
      data = [];
    }

    this.write_struct(data, obj, stt);
    return data;
  }

  read_object(data, cls_or_struct_id, uctx) {
    var cls, stt;

    if (data instanceof Array) {
      data = new DataView(new Uint8Array(data).buffer);
    }

    if (typeof cls_or_struct_id == &quot;number&quot;) {
      cls = this.struct_cls[this.struct_ids[cls_or_struct_id].name];
    } else {
      cls = cls_or_struct_id;
    }

    if (cls === undefined) {
      throw new Error(&quot;bad cls_or_struct_id &quot; + cls_or_struct_id);
    }

    stt = this.structs[cls.structName];

    if (uctx == undefined) {
      uctx = new struct_binpack.unpack_context();

      packer_debug(&quot;\n\n=Begin reading &quot; + cls.structName + &quot;=&quot;);
    }
    var thestruct = this;

    var unpack_funcs = [
      function t_int(type) { //int
        var ret = struct_binpack.unpack_int(data, uctx);

        packer_debug(&quot;-int &quot; + (debug_struct &gt; 1 ? ret : &quot;&quot;));

        return ret;
      }, function t_float(type) {
        var ret = struct_binpack.unpack_float(data, uctx);

        packer_debug(&quot;-float &quot; + (debug_struct &gt; 1 ? ret : &quot;&quot;));

        return ret;
      }, function t_double(type) {
        var ret = struct_binpack.unpack_double(data, uctx);

        packer_debug(&quot;-double &quot; + (debug_struct &gt; 1 ? ret : &quot;&quot;));

        return ret;
      }, 0, 0, 0, 0,
      function t_string(type) {
        packer_debug_start(&quot;string&quot;);

        var s = struct_binpack.unpack_string(data, uctx);

        packer_debug(&quot;data: &apos;&quot; + s + &quot;&apos;&quot;);
        packer_debug_end(&quot;string&quot;);
        return s;
      }, function t_static_string(type) {
        packer_debug_start(&quot;static_string&quot;);

        var s = struct_binpack.unpack_static_string(data, uctx, type.data.maxlength);

        packer_debug(&quot;data: &apos;&quot; + s + &quot;&apos;&quot;);
        packer_debug_end(&quot;static_string&quot;);

        return s;
      }, function t_struct(type) {
        packer_debug_start(&quot;struct &quot; + type.data);

        var cls2 = thestruct.get_struct_cls(type.data);
        var ret = thestruct.read_object(data, cls2, uctx);

        packer_debug_end(&quot;struct&quot;);
        return ret;
      }, function t_tstruct(type) {
        packer_debug_start(&quot;tstruct&quot;);

        var id = struct_binpack.unpack_int(data, uctx);

        packer_debug(&quot;-int &quot; + id);
        if (!(id in thestruct.struct_ids)) {
          packer_debug(&quot;struct id: &quot; + id);
          console.trace();
          console.log(id);
          console.log(thestruct.struct_ids);
          packer_debug_end(&quot;tstruct&quot;);
          throw new Error(&quot;Unknown struct type &quot; + id + &quot;.&quot;);
        }

        var cls2 = thestruct.get_struct_id(id);

        packer_debug(&quot;struct name: &quot; + cls2.name);
        cls2 = thestruct.struct_cls[cls2.name];

        var ret = thestruct.read_object(data, cls2, uctx);

        packer_debug_end(&quot;tstruct&quot;);
        return ret;
      }, function t_array(type) {
        packer_debug_start(&quot;array&quot;);

        var len = struct_binpack.unpack_int(data, uctx);
        packer_debug(&quot;-int &quot; + len);

        var arr = new Array(len);
        for (var i = 0; i &lt; len; i++) {
          arr[i] = unpack_field(type.data.type);
        }

        packer_debug_end(&quot;array&quot;);
        return arr;
      }, function t_iter(type) {
        packer_debug_start(&quot;iter&quot;);

        var len = struct_binpack.unpack_int(data, uctx);
        packer_debug(&quot;-int &quot; + len);

        var arr = new Array(len);
        for (var i = 0; i &lt; len; i++) {
          arr[i] = unpack_field(type.data.type);
        }

        packer_debug_end(&quot;iter&quot;);
        return arr;
      }, function t_short(type) { //int
        var ret = struct_binpack.unpack_short(data, uctx);

        packer_debug(&quot;-short &quot; + ret);

        return ret;
      }, function t_byte(type) {
        var ret = struct_binpack.unpack_byte(data, uctx);

        packer_debug(&quot;-byte &quot; + ret);

        return ret;
      }, function t_bool(type) {
        var ret = struct_binpack.unpack_byte(data, uctx);

        packer_debug(&quot;-bool &quot; + ret);

        return !!ret;
      }, function t_iterkeys(type) {
        packer_debug_start(&quot;iterkeys&quot;);

        var len = struct_binpack.unpack_int(data, uctx);
        packer_debug(&quot;-int &quot; + len);

        var arr = new Array(len);
        for (var i = 0; i &lt; len; i++) {
          arr[i] = unpack_field(type.data.type);
        }

        packer_debug_end(&quot;iterkeys&quot;);
        return arr;
      }
    ];

    function unpack_field(type) {
      return unpack_funcs[type.type](type);
    }

    let was_run = false;

    function load(obj) {
      if (was_run) {
        return;
      }

      was_run = true;

      var fields = stt.fields;
      var flen = fields.length;
      for (var i = 0; i &lt; flen; i++) {
        var f = fields[i];
        var val = unpack_field(f.type);
        obj[f.name] = val;
      }
    }

    if (cls.prototype.loadSTRUCT !== undefined) {
      let obj;

      if (cls.newSTRUCT !== undefined) {
        obj = cls.newSTRUCT();
      } else {
        obj = new cls();
      }

      obj.loadSTRUCT(load);
      return obj;
    } else if (cls.fromSTRUCT !== undefined) {
      if (warninglvl &gt; 1) 
        console.warn(&quot;Warning: class &quot; + cls.name + &quot; is using deprecated fromSTRUCT interface; use newSTRUCT/loadSTRUCT instead&quot;);
      return cls.fromSTRUCT(load);
    } else { //default case, make new instance and then call load() on it
      let obj;
      if (cls.newSTRUCT !== undefined) {
        obj = cls.newSTRUCT();
      } else {
        obj = new cls();
      }

      load(obj);

      return obj;
    }
  }
}

//main struct script manager
var manager = exports.manager = new STRUCT();

/**
 * Write all defined structs out to a string.
 *
 * @param manager STRUCT instance, defaults to nstructjs.manager
 * @param include_code include save code snippets
 * */
var write_scripts = exports.write_scripts = function write_scripts(manager, include_code = false) {
  if (manager === undefined)
    manager = exports.manager;

  var buf = &quot;&quot;;

  manager.forEach(function (stt) {
    buf += STRUCT.fmt_struct(stt, false, !include_code) + &quot;\n&quot;;
  });

  var buf2 = buf;
  buf = &quot;&quot;;

  for (var i = 0; i &lt; buf2.length; i++) {
    var c = buf2[i];
    if (c === &quot;\n&quot;) {
      buf += &quot;\n&quot;;
      var i2 = i;
      while (i &lt; buf2.length &amp;&amp; (buf2[i] === &quot; &quot; || buf2[i] === &quot;\t&quot; || buf2[i] === &quot;\n&quot;)) {
        i++;
      }
      if (i !== i2)
        i--;
    }
    else {
      buf += c;
    }
  }

  return buf;
}
</code></pre>

</div>

<footer class="footer">
  Generated by <a href="https://esdoc.org">ESDoc<span data-ice="esdocVersion">(1.1.0)</span><img src="./image/esdoc-logo-mini-black.png"></a>
</footer>

<script src="script/search_index.js"></script>
<script src="script/search.js"></script>
<script src="script/pretty-print.js"></script>
<script src="script/inherited-summary.js"></script>
<script src="script/test-summary.js"></script>
<script src="script/inner-link.js"></script>
<script src="script/patch-for-local.js"></script>
</body>
</html>
