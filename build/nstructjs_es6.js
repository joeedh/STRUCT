class t{constructor(t,e,r,n,s,i){this.type=t,this.value=e,this.lexpos=r,this.lineno=n,this.lexer=s,this.parser=i}toString(){return void 0!==this.value?"token(type="+this.type+", value='"+this.value+"')":"token(type="+this.type+")"}}class e{constructor(t,e,r,n){if(this.name=t,this.re=e,this.func=r,this.example=n,void 0===n&&e){let t=""+e;t.startsWith("/")&&t.endsWith("/")&&(t=t.slice(1,t.length-1)),t.startsWith("\\")&&(t=t.slice(1,t.length)),t=t.trim(),1===t.length&&(this.example=t)}}}class r extends Error{constructor(t){super()}}class n{constructor(t,e){this.tokdef=t,this.tokens=new Array,this.lexpos=0,this.lexdata="",this.lineno=0,this.errfunc=e,this.tokints={};for(let e=0;e<t.length;e++)this.tokints[t[e].name]=e;this.statestack=[["__main__",0]],this.states={__main__:[t,e]},this.statedata=0}add_state(t,e,r){void 0===r&&(r=function(t){return!0}),this.states[t]=[e,r]}tok_int(t){}push_state(t,e){this.statestack.push([t,e]),t=this.states[t],this.statedata=e,this.tokdef=t[0],this.errfunc=t[1]}pop_state(){let t=this.statestack[this.statestack.length-1],e=this.states[t[0]];this.tokdef=e[0],this.errfunc=e[1],this.statedata=t[1]}input(t){for(;this.statestack.length>1;)this.pop_state();this.lexdata=t,this.lexpos=0,this.lineno=0,this.tokens=new Array,this.peeked_tokens=[]}error(){if(void 0!==this.errfunc&&!this.errfunc(this))return;console.log("Syntax error near line "+this.lineno);let t=Math.min(this.lexpos+8,this.lexdata.length);throw console.log("  "+this.lexdata.slice(this.lexpos,t)),new r("Parse error")}peek(){let t=this.next(!0);if(void 0!==t)return this.peeked_tokens.push(t),t}peeknext(){return this.peeked_tokens.length>0?this.peeked_tokens[0]:this.peek()}at_end(){return this.lexpos>=this.lexdata.length&&0===this.peeked_tokens.length}next(e){if(!e&&this.peeked_tokens.length>0){let t=this.peeked_tokens[0];return this.peeked_tokens.shift(),t}if(this.lexpos>=this.lexdata.length)return;let r=this.tokdef,n=r.length,s=this.lexdata.slice(this.lexpos,this.lexdata.length),i=[];for(var a=0;a<n;a++){let t=r[a];if(void 0===t.re)continue;let e=t.re.exec(s);null!=e&&0===e.index&&i.push([t,e])}let o,c=0;for(a=0;a<i.length;a++){let t=i[a];t[1][0].length>c&&(o=t,c=t[1][0].length)}if(void 0===o)return void this.error();let l=o[0],u=new t(l.name,o[1][0],this.lexpos,this.lineno,this,void 0);return this.lexpos+=u.value.length,l.func&&(u=l.func(u),void 0===u)?this.next():u}}class s{constructor(t,e){this.lexer=t,this.errfunc=e,this.start=void 0}parse(t,e){void 0===e&&(e=!0),void 0!==t&&this.lexer.input(t);let r=this.start(this);return e&&!this.lexer.at_end()&&void 0!==this.lexer.next()&&this.error(void 0,"parser did not consume entire input"),r}input(t){this.lexer.input(t)}error(t,e){let n;void 0===e&&(e=""),n=void 0===t?"Parse error at end of input: "+e:"Parse error at line "+(t.lineno+1)+": "+e;let s="1| ",i=this.lexer.lexdata,a=1;for(var o=0;o<i.length;o++){let t=i[o];"\n"===t?(a++,s+="\n"+a+"| "):s+=t}if(console.log("------------------"),console.log(s),console.log("=================="),console.log(n),!this.errfunc||this.errfunc(t))throw new r(n)}peek(){let t=this.lexer.peek();return void 0!==t&&(t.parser=this),t}peeknext(){let t=this.lexer.peeknext();return void 0!==t&&(t.parser=this),t}next(){let t=this.lexer.next();return void 0!==t&&(t.parser=this),t}optional(t){let e=this.peek();return void 0!==e&&(e.type===t&&(this.next(),!0))}at_end(){return this.lexer.at_end()}expect(t,e){let r=this.next();if(void 0===e){e=t;for(let r of this.lexer.tokdef)r.name===t&&r.example&&(e=r.example)}return void 0!==r&&r.type===t||this.error(r,"Expected "+e),r.value}}var i=Object.freeze({__proto__:null,token:t,tokdef:e,PUTIL_ParseError:r,lexer:n,parser:s});class a{constructor(t){this.fields=[],this.id=-1,this.name=t}}const o={T_INT:0,T_FLOAT:1,T_DOUBLE:2,T_STRING:7,T_STATIC_STRING:8,T_STRUCT:9,T_TSTRUCT:10,T_ARRAY:11,T_ITER:12,T_SHORT:13,T_BYTE:14,T_BOOL:15,T_ITERKEYS:16,T_UINT:17,T_USHORT:18,T_STATIC_ARRAY:19,T_SIGNED_BYTE:20},c=new Set([o.T_INT,o.T_FLOAT,o.T_DOUBLE,o.T_STRING,o.T_STATIC_STRING,o.T_SHORT,o.T_BYTE,o.T_BOOL,o.T_UINT,o.T_USHORT,o.T_SIGNED_BYTE]);let l={int:o.T_INT,uint:o.T_UINT,ushort:o.T_USHORT,float:o.T_FLOAT,double:o.T_DOUBLE,string:o.T_STRING,static_string:o.T_STATIC_STRING,struct:o.T_STRUCT,abstract:o.T_TSTRUCT,array:o.T_ARRAY,iter:o.T_ITER,short:o.T_SHORT,byte:o.T_BYTE,bool:o.T_BOOL,iterkeys:o.T_ITERKEYS,sbyte:o.T_SIGNED_BYTE},u={};for(let t in l)u[l[t]]=t;const p=function(){let t=new Set(["int","float","double","string","short","byte","sbyte","bool","uint","ushort"]),r=new Set(["int","float","double","string","static_string","array","iter","abstract","short","byte","sbyte","bool","iterkeys","uint","ushort","static_array"]);function i(t,r,n){return new e(t,r,n)}let c=[i("ID",/[a-zA-Z_$]+[a-zA-Z0-9_\.$]*/,(function(t){return r.has(t.value)&&(t.type=t.value.toUpperCase()),t})),i("OPEN",/\{/),i("EQUALS",/=/),i("CLOSE",/}/),i("COLON",/:/),i("SOPEN",/\[/),i("SCLOSE",/\]/),i("JSCRIPT",/\|/,(function(t){let e="",r=t.lexer;for(;r.lexpos<r.lexdata.length;){let t=r.lexdata[r.lexpos];if("\n"===t)break;e+=t,r.lexpos++}for(;e.trim().endsWith(";");)e=e.slice(0,e.length-1),r.lexpos--;return t.value=e.trim(),t})),i("LPARAM",/\(/),i("RPARAM",/\)/),i("COMMA",/,/),i("NUM",/[0-9]+/,void 0),i("SEMI",/;/),i("NEWLINE",/\n/,(function(t){t.lexer.lineno+=1})),i("SPACE",/ |\t/,(function(t){}))];r.forEach((function(t){c.push(i(t.toUpperCase()))}));let u=new n(c,(function(t){return!0})),p=new s(u);function d(e){let r=e.peek();return"ID"===r.type?(e.next(),{type:o.T_STRUCT,data:r.value}):t.has(r.type.toLowerCase())?(e.next(),{type:l[r.type.toLowerCase()]}):"ARRAY"===r.type?function(t){t.expect("ARRAY"),t.expect("LPARAM");let e=d(t),r="";return t.optional("COMMA")&&(r=e.data.replace(/"/g,""),e=d(t)),t.expect("RPARAM"),{type:o.T_ARRAY,data:{type:e,iname:r}}}(e):"ITER"===r.type?function(t){t.expect("ITER"),t.expect("LPARAM");let e=d(t),r="";return t.optional("COMMA")&&(r=e.data.replace(/"/g,""),e=d(t)),t.expect("RPARAM"),{type:o.T_ITER,data:{type:e,iname:r}}}(e):"ITERKEYS"===r.type?function(t){t.expect("ITERKEYS"),t.expect("LPARAM");let e=d(t),r="";return t.optional("COMMA")&&(r=e.data.replace(/"/g,""),e=d(t)),t.expect("RPARAM"),{type:o.T_ITERKEYS,data:{type:e,iname:r}}}(e):"STATIC_ARRAY"===r.type?function(t){t.expect("STATIC_ARRAY"),t.expect("SOPEN");let e=d(t),r="";t.expect("COMMA");let n=t.expect("NUM");return(n<0||Math.abs(n-Math.floor(n))>1e-6)&&(console.log(Math.abs(n-Math.floor(n))),t.error("Expected an integer")),n=Math.floor(n),t.optional("COMMA")&&(r=d(t).data),t.expect("SCLOSE"),{type:o.T_STATIC_ARRAY,data:{type:e,size:n,iname:r}}}(e):"STATIC_STRING"===r.type?function(t){t.expect("STATIC_STRING"),t.expect("SOPEN");let e=t.expect("NUM");return t.expect("SCLOSE"),{type:o.T_STATIC_STRING,data:{maxlength:e}}}(e):"ABSTRACT"===r.type?function(t){t.expect("ABSTRACT"),t.expect("LPARAM");let e=t.expect("ID");return t.expect("RPARAM"),{type:o.T_TSTRUCT,data:e}}(e):"DATAREF"===r.type?function(t){t.expect("DATAREF"),t.expect("LPARAM");let e=t.expect("ID");return t.expect("RPARAM"),{type:o.T_DATAREF,data:e}}(e):void e.error(r,"invalid type "+r.type)}function f(t){let e={};e.name=function(t){let e=t.peeknext();return"NUM"===e.type?(t.next(),e.value):t.expect("ID","struct field name")}(t),t.expect("COLON"),e.type=d(t),e.set=void 0,e.get=void 0;let r=0,n=t.peek();return"JSCRIPT"===n.type&&(e.get=n.value,r=1,t.next()),n=t.peek(),"JSCRIPT"===n.type&&(r=1,e.set=n.value,t.next()),t.expect("SEMI"),e}return p.start=function(t){let e=t.expect("ID","struct name"),r=new a(e),n=t.peek();for("ID"===n.type&&"id"===n.value&&(t.next(),t.expect("EQUALS"),r.id=t.expect("NUM")),t.expect("OPEN");;)if(t.at_end())t.error(void 0);else{if(t.optional("CLOSE"))break;r.fields.push(f(t))}return r},p}();var d=Object.freeze({__proto__:null,NStruct:a,StructEnum:o,ValueTypes:c,StructTypes:l,StructTypeMap:u,struct_parse:p}),f=Object.freeze({__proto__:null}),h=!0;function _(t){h=!!t}let T=new DataView(new ArrayBuffer(16)),m=new Uint8Array(T.buffer);class g{constructor(){this.i=0}}function y(t,e){t.push(e)}function S(t,e){e<0&&(e=256+e),t.push(e)}function w(t,e){for(let r=0;r<e.length;r++)t.push(e[r])}function k(t,e){T.setInt32(0,e,h),t.push(m[0]),t.push(m[1]),t.push(m[2]),t.push(m[3])}function v(t,e){T.setUint32(0,e,h),t.push(m[0]),t.push(m[1]),t.push(m[2]),t.push(m[3])}function R(t,e){T.setUint16(0,e,h),t.push(m[0]),t.push(m[1])}function x(t,e){T.setFloat32(0,e,h),t.push(m[0]),t.push(m[1]),t.push(m[2]),t.push(m[3])}function A(t,e){T.setFloat64(0,e,h),t.push(m[0]),t.push(m[1]),t.push(m[2]),t.push(m[3]),t.push(m[4]),t.push(m[5]),t.push(m[6]),t.push(m[7])}function N(t,e){T.setInt16(0,e,h),t.push(m[0]),t.push(m[1])}function b(t,e){for(let r=0;r<e.length;r++){let n=e.charCodeAt(r);for(;0!==n;){let e=127&n;n>>=7,0!==n&&(e|=128),t.push(e)}}}function C(t){let e="",r=0;for(;r<t.length;){let n=t[r],s=127&n,i=0;for(;r<t.length&&128&n;)i+=7,r++,n=t[r],n=(127&n)<<i,s|=n;if(0===s)break;e+=String.fromCharCode(s),r++}return e}function U(t,e){let r=Math.min(t.length,e),n=0,s=0,i=!1,a=0;for(;a<r;)i=128&t[a],i||(s=n+1,n=a+1),a++;return t.length=n<e?n:s,t}let E=new Array(2048);function O(t,e,r){if(void 0===r)throw new Error("'length' paremter is not optional for pack_static_string()");let n=r<2048?E:new Array;n.length=0,b(n,e),U(n,r);for(let e=0;e<r;e++)e>=n.length?t.push(0):t.push(n[e])}let I=new Array(32);function M(t,e){I.length=0,b(I,e),k(t,I.length);for(let e=0;e<I.length;e++)t.push(I[e])}function j(t,e,r){let n=new DataView(t.buffer.slice(e.i,e.i+r));return e.i+=r,n}function J(t,e){return t.getUint8(e.i++)}function L(t,e){return t.getInt8(e.i++)}function Y(t,e){return e.i+=4,t.getInt32(e.i-4,h)}function B(t,e){return e.i+=4,t.getUint32(e.i-4,h)}function D(t,e){return e.i+=2,t.getUint16(e.i-2,h)}function P(t,e){return e.i+=4,t.getFloat32(e.i-4,h)}function z(t,e){return e.i+=8,t.getFloat64(e.i-8,h)}function F(t,e){return e.i+=2,t.getInt16(e.i-2,h)}let W=new Array(32);function H(t,e){let r=Y(t,e);if(!r)return"";let n=r<2048?W:new Array(r);n.length=r;for(let s=0;s<r;s++)n[s]=J(t,e);return C(n)}let G=new Array(2048);function V(t,e,r){if(void 0===r)throw new Error("'length' cannot be undefined in unpack_static_string()");let n=r<2048?G:new Array(r);n.length=0;let s=!1;for(let i=0;i<r;i++){let r=J(t,e);0===r&&(s=!0),s||0===r||n.push(r)}return U(n,r),C(n)}var $=Object.freeze({__proto__:null,get STRUCT_ENDIAN(){return h},setEndian:_,unpack_context:g,pack_byte:y,pack_sbyte:S,pack_bytes:w,pack_int:k,pack_uint:v,pack_ushort:R,pack_float:x,pack_double:A,pack_short:N,encode_utf8:b,decode_utf8:C,test_utf8:function(){let t="a"+String.fromCharCode(8800)+"b",e=[];if(b(e,t),t!==C(e))throw new Error("UTF-8 encoding/decoding test failed");return!0},pack_static_string:O,pack_string:M,unpack_bytes:j,unpack_byte:J,unpack_sbyte:L,unpack_int:Y,unpack_uint:B,unpack_ushort:D,unpack_float:P,unpack_double:z,unpack_short:F,unpack_string:H,unpack_static_string:V});let K,Q,Z,q=1,X=0,tt=0;class et extends Array{constructor(t,e){super(),this.length=e,this.cur=0;for(let r=0;r<e;r++)this[r]=t()}next(){let t=this[this.cur];return this.cur=(this.cur+1)%this.length,t}static fromConstructor(t,e){return new et((()=>new t),e)}}function rt(t){X=t,X?(K=function(t){if(void 0!==t){let e=function(t){let e="";for(let r=0;r<t;r++)e+=" ";return e}(tt);console.log(e+t)}else console.log("Warning: undefined msg")},Q=function(t){K("Start "+t),tt++},Z=function(t){tt--,K("Leave "+t)}):(K=function(){},Q=function(){},Z=function(){})}rt(X);const nt=[],st={};function it(t,e,r,n){st[n.type].packNull(t,e,r,n)}function at(t,e,r,n,s){return st[s.type].toJSON(t,e,r,n,s)}function ot(t,e,r,n,s,i){return st[s.type].fromJSON(t,e,r,n,s,i)}function ct(t,e,r,n){let s;X&&(s=st[r.type].define().name,Q("R start "+s));let i=st[r.type].unpack(t,e,r,n);return X&&Z("R end "+s),i}let lt=new et((()=>({type:void 0,get:void 0,set:void 0})),256);function ut(t){return st[t.type].format(t)}function pt(t,e,r,n,s,i){let a;X&&(a=st[i.type].define().name,Q("W start "+a));let o=i;"number"!=typeof o&&(o=o.type);let c=st[o].pack(t,e,r,n,s,i);return X&&Z("W end "+a),c}let dt=[[void 0,void 0]];class ft{static pack(t,e,r,n,s,i){}static unpack(t,e,r,n){}static packNull(t,e,r,n){this.pack(t,e,0,0,r,n)}static format(t){return this.define().name}static toJSON(t,e,r,n,s){return e}static fromJSON(t,e,r,n,s,i){return e}static useHelperJS(t){return!0}static define(){return{type:-1,name:"(error)"}}static register(t){if(nt.indexOf(t)>=0)throw new Error("class already registered");if(t.define===ft.define)throw new Error("you forgot to make a define() static method");if(void 0===t.define().type)throw new Error("cls.define().type was undefined!");if(t.define().type in st)throw new Error("type "+t.define().type+" is used by another StructFieldType subclass");nt.push(t),st[t.define().type]=t}}ft.register(class extends ft{static pack(t,e,r,n,s,i){k(e,r)}static unpack(t,e,r,n){return Y(e,n)}static define(){return{type:o.T_INT,name:"int"}}});ft.register(class extends ft{static pack(t,e,r,n,s,i){x(e,r)}static unpack(t,e,r,n){return P(e,n)}static define(){return{type:o.T_FLOAT,name:"float"}}});ft.register(class extends ft{static pack(t,e,r,n,s,i){A(e,r)}static unpack(t,e,r,n){return z(e,n)}static define(){return{type:o.T_DOUBLE,name:"double"}}});ft.register(class extends ft{static pack(t,e,r,n,s,i){M(e,r=r||"")}static packNull(t,e,r,n){this.pack(t,e,"",0,r,n)}static unpack(t,e,r,n){return H(e,n)}static define(){return{type:o.T_STRING,name:"string"}}});ft.register(class extends ft{static pack(t,e,r,n,s,i){O(e,r=r||"",i.data.maxlength)}static format(t){return`static_string[${t.data.maxlength}]`}static packNull(t,e,r,n){this.pack(t,e,"",0,r,n)}static unpack(t,e,r,n){return V(e,n,r.data.maxlength)}static define(){return{type:o.T_STATIC_STRING,name:"static_string"}}});ft.register(class extends ft{static pack(t,e,r,n,s,i){t.write_struct(e,r,t.get_struct(i.data))}static format(t){return t.data}static fromJSON(t,e,r,n,s,i){let a=t.get_struct(s.data);return t.readJSON(e,a,i)}static toJSON(t,e,r,n,s){let i=t.get_struct(s.data);return t.writeJSON(e,i)}static unpackInto(t,e,r,n,s){let i=t.get_struct_cls(r.data);return t.read_object(e,i,n,s)}static packNull(t,e,r,n){let s=t.get_struct(n.data);for(let r of s.fields){it(t,e,r,r.type)}}static unpack(t,e,r,n){let s=t.get_struct_cls(r.data);return t.read_object(e,s,n)}static define(){return{type:o.T_STRUCT,name:"struct"}}});ft.register(class extends ft{static pack(t,e,r,n,s,i){let a=t.get_struct_cls(i.data),o=t.get_struct(i.data);if(r.constructor.structName!==i.data&&r instanceof a)o=t.get_struct(r.constructor.structName);else{if(r.constructor.structName!==i.data)throw console.trace(),new Error("Bad struct "+r.constructor.structName+" passed to write_struct");o=t.get_struct(i.data)}K("int "+o.id),k(e,o.id),t.write_struct(e,r,o)}static fromJSON(t,e,r,n,s,i){let a=t.get_struct(e._structName);return t.readJSON(e,a,i)}static toJSON(t,e,r,n,s){let i=t.get_struct(e.constructor.structName),a=t.writeJSON(e,i);return a._structName=""+i.name,a}static packNull(t,e,r,n){k(e,t.get_struct(n.data).id),it(t,e,r,{type:o.T_STRUCT,data:n.data})}static format(t){return"abstract("+t.data+")"}static unpackInto(t,e,r,n,s){let i=Y(e,n);if(K("-int "+i),!(i in t.struct_ids))throw K("struct id: "+i),console.trace(),console.log(i),console.log(t.struct_ids),Z("tstruct"),new Error("Unknown struct type "+i+".");let a=t.get_struct_id(i);return K("struct name: "+a.name),a=t.struct_cls[a.name],t.read_object(e,a,n,s)}static unpack(t,e,r,n){let s=Y(e,n);if(K("-int "+s),!(s in t.struct_ids))throw K("struct id: "+s),console.trace(),console.log(s),console.log(t.struct_ids),Z("tstruct"),new Error("Unknown struct type "+s+".");let i=t.get_struct_id(s);return K("struct name: "+i.name),i=t.struct_cls[i.name],t.read_object(e,i,n)}static define(){return{type:o.T_TSTRUCT,name:"tstruct"}}});class ht extends ft{static pack(t,e,r,n,s,i){if(void 0===r)return console.trace(),console.log("Undefined array fed to struct struct packer!"),console.log("Field: ",s),console.log("Type: ",i),console.log(""),K("int 0"),void k(e,0);K("int "+r.length),k(e,r.length);let a=i.data,o=a.iname,c=a.type,l=dt;for(let i=0;i<r.length;i++){let a=r[i];""!==o&&void 0!==o&&s.get&&(l[0][0]=o,l[0][1]=a,a=t._env_call(s.get,n,l));let u=lt.next();u.type=c,pt(t,e,a,n,u,c)}}static packNull(t,e,r,n){k(e,0)}static format(t){return""!==t.data.iname&&void 0!==t.data.iname?"array("+t.data.iname+", "+ut(t.data.type)+")":"array("+ut(t.data.type)+")"}static useHelperJS(t){return!t.type.data.iname}static fromJSON(t,e,r,n,s,i){let a=i||[];a.length=0;for(let r=0;r<e.length;r++){let i=ot(t,e[r],e,n,s.data.type,void 0);void 0===i&&(console.log(i),console.error("eeek"),process.exit()),a.push(i)}return a}static toJSON(t,e,r,n,s){e=e||[];let i=[],a=s.data.iname;for(let o=0;o<e.length;o++){let c=e[o],l=dt;""!==a&&void 0!==a&&n.get&&(l[0][0]=a,l[0][1]=c,c=t._env_call(n.get,r,l)),i.push(at(t,c,e,n,s.data.type))}return i}static unpackInto(t,e,r,n,s){let i=Y(e,n);s.length=0;for(let a=0;a<i;a++)s.push(ct(t,e,r.data.type,n))}static unpack(t,e,r,n){let s=Y(e,n);K("-int "+s);let i=new Array(s);for(let a=0;a<s;a++)i[a]=ct(t,e,r.data.type,n);return i}static define(){return{type:o.T_ARRAY,name:"array"}}}ft.register(ht);ft.register(class extends ft{static pack(t,e,r,n,s,i){function a(t,e){if(r&&r[Symbol.iterator])for(let n of r)t.call(e,n);else r&&r.forEach?r.forEach((function(r){t.call(e,r)})):(console.trace(),console.log("Undefined iterable list fed to struct struct packer!",r),console.log("Field: ",s),console.log("Type: ",i),console.log(""))}let o=0;a((()=>{o++})),K("int "+o),k(e,o);let c=i.data,l=c.iname,u=c.type,p=dt,d=0;a((function(i){if(d>=o)return void(q>0&&console.trace("Warning: iterator returned different length of list!",r,d));""!==l&&void 0!==l&&s.get&&(p[0][0]=l,p[0][1]=i,i=t._env_call(s.get,n,p));let a=lt.next();a.type=u,pt(t,e,i,n,a,u),d++}),this)}static fromJSON(){return ht.fromJSON(...arguments)}static toJSON(t,e,r,n,s){e=e||[];let i=[],a=s.data.iname;for(let o of e){let c=dt;""!==a&&void 0!==a&&n.get&&(c[0][0]=a,c[0][1]=o,o=t._env_call(n.get,r,c)),i.push(at(t,o,e,n,s.data.type))}return i}static packNull(t,e,r,n){k(e,0)}static useHelperJS(t){return!t.type.data.iname}static format(t){return""!==t.data.iname&&void 0!==t.data.iname?"iter("+t.data.iname+", "+ut(t.data.type)+")":"iter("+ut(t.data.type)+")"}static unpackInto(t,e,r,n,s){let i=Y(e,n);K("-int "+i),s.length=0;for(let a=0;a<i;a++)s.push(ct(t,e,r.data.type,n));return s}static unpack(t,e,r,n){let s=Y(e,n);K("-int "+s);let i=new Array(s);for(let a=0;a<s;a++)i[a]=ct(t,e,r.data.type,n);return i}static define(){return{type:o.T_ITER,name:"iter"}}});ft.register(class extends ft{static pack(t,e,r,n,s,i){N(e,r)}static unpack(t,e,r,n){return F(e,n)}static define(){return{type:o.T_SHORT,name:"short"}}});ft.register(class extends ft{static pack(t,e,r,n,s,i){y(e,r)}static unpack(t,e,r,n){return J(e,n)}static define(){return{type:o.T_BYTE,name:"byte"}}});ft.register(class extends ft{static pack(t,e,r,n,s,i){S(e,r)}static unpack(t,e,r,n){return L(e,n)}static define(){return{type:o.T_SIGNED_BYTE,name:"sbyte"}}});ft.register(class extends ft{static pack(t,e,r,n,s,i){y(e,!!r)}static unpack(t,e,r,n){return!!J(e,n)}static define(){return{type:o.T_BOOL,name:"bool"}}});ft.register(class extends ft{static pack(t,e,r,n,s,i){if("object"!=typeof r&&"function"!=typeof r||null===r)return console.warn("Bad object fed to iterkeys in struct packer!",r),console.log("Field: ",s),console.log("Type: ",i),console.log(""),k(e,0),void Z("iterkeys");let a=0;for(let t in r)a++;K("int "+a),k(e,a);let o=i.data,c=o.iname,l=o.type,u=dt,p=0;for(let i in r){if(p>=a)return void(q>0&&console.warn("Warning: object keys magically replaced on us",r,p));c&&c.trim().length>0&&s.get?(u[0][0]=c,u[0][1]=i,i=t._env_call(s.get,n,u)):i=r[i],pt(t,e,i,n,{type:l,get:void 0,set:void 0},l),p++}}static fromJSON(){return ht.fromJSON(...arguments)}static toJSON(t,e,r,n,s){e=e||[];let i=[],a=s.data.iname;for(let o in e){let c=e[o],l=dt;""!==a&&void 0!==a&&n.get&&(l[0][0]=a,l[0][1]=c,c=t._env_call(n.get,r,l)),i.push(at(t,c,e,n,s.data.type))}return i}static packNull(t,e,r,n){k(e,0)}static useHelperJS(t){return!t.type.data.iname}static format(t){return""!==t.data.iname&&void 0!==t.data.iname?"iterkeys("+t.data.iname+", "+ut(t.data.type)+")":"iterkeys("+ut(t.data.type)+")"}static unpackInto(t,e,r,n,s){let i=Y(e,n);K("-int "+i),s.length=0;for(let a=0;a<i;a++)s.push(ct(t,e,r.data.type,n));return s}static unpack(t,e,r,n){let s=Y(e,n);K("-int "+s);let i=new Array(s);for(let a=0;a<s;a++)i[a]=ct(t,e,r.data.type,n);return i}static define(){return{type:o.T_ITERKEYS,name:"iterkeys"}}});ft.register(class extends ft{static pack(t,e,r,n,s,i){v(e,r)}static unpack(t,e,r,n){return B(e,n)}static define(){return{type:o.T_UINT,name:"uint"}}});ft.register(class extends ft{static pack(t,e,r,n,s,i){R(e,r)}static unpack(t,e,r,n){return D(e,n)}static define(){return{type:o.T_USHORT,name:"ushort"}}});ft.register(class extends ft{static pack(t,e,r,n,s,i){if(void 0===i.data.size)throw new Error("type.data.size was undefined");let a=i.data.iname;if(void 0!==r&&r.length)for(let o=0;o<i.data.size;o++){let c=r[Math.min(o,Math.min(r.length-1,i.data.size))];if(""!==a&&void 0!==a&&s.get){let e=dt;e[0][0]=a,e[0][1]=c,c=t._env_call(s.get,n,e)}pt(t,e,c,r,s,i.data.type)}else this.packNull(t,e,s,i)}static useHelperJS(t){return!t.type.data.iname}static fromJSON(){return ht.fromJSON(...arguments)}static packNull(t,e,r,n){let s=n.data.size;for(let i=0;i<s;i++)it(t,e,r,n.data.type)}static toJSON(t,e,r,n,s){return ht.toJSON(...arguments)}static format(t){let e=`static_array[${st[t.data.type.type].format(t.data.type)}, ${t.data.size}`;return t.data.iname&&(e+=`, ${t.data.iname}`),e+="]",e}static unpackInto(t,e,r,n,s){K("-size: "+r.data.size),s.length=0;for(let i=0;i<r.data.size;i++)s.push(ct(t,e,r.data.type,n));return s}static unpack(t,e,r,n){K("-size: "+r.data.size);let s=[];for(let i=0;i<r.data.size;i++)s.push(ct(t,e,r.data.type,n));return s}static define(){return{type:o.T_STATIC_ARRAY,name:"static_array"}}});var _t=eval;"undefined"!=typeof globalThis?globalThis:"undefined"!=typeof window?window:"undefined"!=typeof global?global:"undefined"!=typeof globals?globals:"undefined"!=typeof self&&self;const Tt={};let mt=2;var gt,yt=!0;function St(t){yt=!!t}function wt(t){let e=t.search("$");return e>0?t.slice(0,e).trim():t}function kt(t){return yt?wt(t):t}let vt,Rt,xt,At=0,Nt=0;function bt(t){let e="";for(let r=0;r<t;r++)e+=" ";return e}function Ct(t){if(function(t){if("number"!=typeof t||isNaN(t))throw new Error("Expected a single number (>= 0) argument to setWarningMode");q=t}(t),"number"!=typeof t||isNaN(t))throw new Error("Expected a single number (>= 0) argument to setWarningMode");mt=t}function Ut(t){At=t,rt(t),At?(vt=function(t){if(void 0!==t){let e=bt(Nt);console.log(e+t)}else console.log("Warning: undefined msg")},Rt=function(t){vt("Start "+t),Nt++},xt=function(t){Nt--,vt("Leave "+t)}):(vt=function(){},Rt=function(){},xt=function(){})}At?(vt=function(t){if(void 0!==t){let e=bt(Nt);console.log(e+t)}else console.log("Warning: undefined msg")},Rt=function(t){vt("Start "+t),Nt++},xt=function(t){Nt--,vt("Leave "+t)}):(vt=function(){},Rt=function(){},xt=function(){});let Et,Ot;function It(t,e,r,n,s,i){st[s.type.type].pack(gt,t,e,r,s,i)}function Mt(t){let e=function(){};return e.prototype=Object.create(Object.prototype),e.constructor=e.prototype.constructor=e,e.STRUCT=t+" {\n  }\n",e.structName=t,e.prototype.loadSTRUCT=function(t){t(this)},e.newSTRUCT=function(){return new this},e}class jt{constructor(){this.idgen=0,this.allowOverriding=!0,this.structs={},this.struct_cls={},this.struct_ids={},this.compiled_code={},this.null_natives={},function(t,e){let r=Mt(t),n=p.parse(r.STRUCT);n.id=this.idgen++,this.structs[t]=n,this.struct_cls[t]=e,this.struct_ids[n.id]=n,this.null_natives[t]=1}.call(this,"Object",Object)}static inherit(t,e,r=t.name){if(!e.STRUCT)return r+"{\n";let n=p.parse(e.STRUCT),s=r+"{\n";return s+=jt.fmt_struct(n,!0),s}static Super(t,e){mt>0&&console.warn("deprecated"),e(t);let r=t.constructor,n=void 0===r||void 0===r.prototype||void 0===r.prototype.__proto__;if(n)return;let s=r.prototype.__proto__.constructor;n=n||void 0===s,!n&&s.prototype.loadSTRUCT&&s.prototype.loadSTRUCT!==t.loadSTRUCT&&s.prototype.loadSTRUCT.call(t,(function(t){}))}static chain_fromSTRUCT(t,e){mt>0&&console.warn("Using deprecated (and evil) chain_fromSTRUCT method, eek!");t.prototype;let r=t.prototype.prototype.constructor.fromSTRUCT(e),n=new t,s=Object.keys(r).concat(Object.getOwnPropertySymbols(r));for(let t=0;t<s.length;t++){let e=s[t];try{n[e]=r[e]}catch(t){mt>0&&console.warn("  failed to set property",e)}}return n}static formatStruct(t,e,r){return this.fmt_struct(t,e,r)}static fmt_struct(t,e,r){void 0===e&&(e=!1),void 0===r&&(r=!1);let n="";e||(n+=t.name,-1!==t.id&&(n+=" id="+t.id),n+=" {\n");function s(t){return st[t.type].format(t)}let i=t.fields;for(let t=0;t<i.length;t++){let e=i[t];n+="  "+e.name+" : "+s(e.type),r||void 0===e.get||(n+=" | "+e.get.trim()),n+=";\n"}return e||(n+="}"),n}validateStructs(t){function e(t){switch(t.type){case o.T_ITERKEYS:case o.T_ITER:case o.T_STATIC_ARRAY:case o.T_ARRAY:return e(t.data.type);default:return t}}function r(e,r,n){let s=jt.formatStruct(e);if(console.error(s+"\n\n"+n),!t)throw new Error(n);t(n,e,r)}for(let t in this.structs){let n=this.structs[t];for(let t of n.fields){if("this"===t.name){let e=t.type.type;c.has(e)&&r(n,t,"'this' cannot be used with value types")}let s=e(t.type);if((s.type===o.T_STRUCT||s.type===o.T_TSTRUCT)&&!(s.data in this.structs)){r(n,t,n.name+":"+t.name+": Unknown struct "+s.data+".")}}}}forEach(t,e){for(let r in this.structs){let n=this.structs[r];void 0!==e?t.call(e,n):t(n)}}parse_structs(t,e){if(void 0===e&&(e=gt),e instanceof jt){let t=e;e=[];for(let r in t.struct_cls)e.push(t.struct_cls[r])}if(void 0===e){e=[];for(let t in gt.struct_cls)e.push(gt.struct_cls[t])}let r={};for(let t=0;t<e.length;t++){let n=e[t];if(!n.structName&&n.STRUCT){let t=p.parse(n.STRUCT.trim());n.structName=t.name}else if(!n.structName&&"Object"!==n.name){mt>0&&console.log("Warning, bad class in registered class list",kt(n.name),n);continue}r[n.structName]=e[t]}for(p.input(t);!p.at_end();){let t=p.parse(void 0,!1);if(t.name in r)this.struct_cls[t.name]=r[t.name],this.structs[t.name]=t,-1!==t.id&&(this.struct_ids[t.id]=t);else{t.name in this.null_natives||mt>0&&console.log("WARNING: struct "+t.name+" is missing from class list.");let e=Mt(t.name);e.STRUCT=jt.fmt_struct(t),e.structName=t.name,e.prototype.structName=e.name,this.struct_cls[e.structName]=e,this.structs[e.structName]=t,-1!==t.id&&(this.struct_ids[t.id]=t)}let e=p.peek();for(;e&&("\n"===e.value||"\r"===e.value||"\t"===e.value||" "===e.value);)e=p.peek()}}register(t,e){return this.add_class(t,e)}unregister(t){if(!t||!t.structName||!(t.structName in this.struct_cls))return void console.warn("Class not registered with nstructjs",t);let e=this.structs[t.structName];delete this.structs[t.structName],delete this.struct_cls[t.structName],delete this.struct_ids[e.id]}add_class(t,e){if(t.STRUCT){let r=!1,n=t;for(;n;)if(n=n.__proto__,n&&n.STRUCT&&n.STRUCT===t.STRUCT){r=!0;break}r&&(console.warn("Generating STRUCT script for derived class "+kt(t.name)),e||(e=kt(t.name)),t.STRUCT=jt.inherit(t,n)+"\n}")}if(!t.STRUCT)throw new Error("class "+kt(t.name)+" has no STRUCT script");let r=p.parse(t.STRUCT);if(r.name=kt(r.name),t.structName=r.name,void 0===t.newSTRUCT&&(t.newSTRUCT=function(){return new this}),void 0!==e?r.name=t.structName=e:void 0===t.structName?t.structName=r.name:r.name=t.structName,t.structName in this.structs){if(console.warn("Struct "+kt(t.structName)+" is already registered",t),!this.allowOverriding)throw new Error("Struct "+kt(t.structName)+" is already registered")}else-1===r.id&&(r.id=this.idgen++),this.structs[t.structName]=r,this.struct_cls[t.structName]=t,this.struct_ids[r.id]=r}isRegistered(t){return!!t.hasOwnProperty("structName")&&t===this.struct_cls[t.structName]}get_struct_id(t){return this.struct_ids[t]}get_struct(t){if(!(t in this.structs))throw console.warn("Unknown struct",t),new Error("Unknown struct "+t);return this.structs[t]}get_struct_cls(t){if(!(t in this.struct_cls))throw console.trace(),new Error("Unknown struct "+t);return this.struct_cls[t]}_env_call(t,e,r){let n="";if(void 0!==r){n="";for(let t=0;t<r.length;t++)n="let "+r[t][0]+" = env["+t.toString()+"][1];\n"+n}let s,i="";if(i=""!==n?n+t:t,i in this.compiled_code)s=this.compiled_code[i];else{let e="func = function(obj, env) { "+n+"return "+t+"}";try{s=_t(e)}catch(t){throw console.warn(t.stack),console.warn(e),console.warn(" "),t}this.compiled_code[i]=s}try{return s.call(e,e,r)}catch(e){console.warn(e.stack);let r="func = function(obj, env) { "+n+"return "+t+"}";throw console.warn(r),console.warn(" "),e}}write_struct(t,e,r){function n(t){let e=t.type.type;return st[e].useHelperJS(t)}let s=r.fields,i=this;for(let r=0;r<s.length;r++){let a=s[r],o=a.type;o.type;if(n(a)){let r;r=void 0!==a.get?i._env_call(a.get,e):"this"===a.name?e:e[a.name],Tt.tinyeval&&console.log("\n\n\n",a.get,"Helper JS Ret",r,"\n\n\n"),It(t,r,e,0,a,o)}else{It(t,"this"===a.name?e:e[a.name],e,0,a,o)}}}write_object(t,e){let r=e.constructor.structName,n=this.get_struct(r);return void 0===t&&(t=[]),this.write_struct(t,e,n),t}readObject(t,e,r){return t instanceof Uint8Array||t instanceof Uint8ClampedArray?t=new DataView(t.buffer):t instanceof Array&&(t=new DataView(new Uint8Array(t).buffer)),this.read_object(t,e,r)}writeObject(t,e){return this.write_object(t,e)}writeJSON(t,e){let r=t.constructor;function n(t){let e=t.type.type;return st[e].useHelperJS(t)}let s=at,i=(e=e||this.get_struct(r.structName)).fields,a=this,o={};for(let e=0;e<i.length;e++){let r,c,u=i[e],p=u.type;if(n(u)?(r=void 0!==u.get?a._env_call(u.get,t):"this"===u.name?t:t[u.name],Tt.tinyeval&&console.log("\n\n\n",u.get,"Helper JS Ret",r,"\n\n\n"),c=s(this,r,t,u,p)):(r="this"===u.name?t:t[u.name],c=s(this,r,t,u,p)),"this"!==u.name)o[u.name]=c;else{let t=Array.isArray(c);if(t=t||u.type.type===l.T_ARRAY,t=t||u.type.type===l.T_STATIC_ARRAY,t){o.length=c.length;for(let t=0;t<c.length;t++)o[t]=c[t]}else Object.assign(o,c)}}return o}read_object(t,e,r,n){let s,i;if(t instanceof Array&&(t=new DataView(new Uint8Array(t).buffer)),s="number"==typeof e?this.struct_cls[this.struct_ids[e].name]:e,void 0===s)throw new Error("bad cls_or_struct_id "+e);i=this.structs[s.structName],void 0===r&&(r=new g,vt("\n\n=Begin reading "+s.structName+"="));let a=this;function o(e){return st[e.type].unpack(a,t,e,r)}let c=!1;let l=function(e){return function(n){if(c)return;c=!0;let s=e.fields,i=s.length;for(let e=0;e<i;e++){let i=s[e];"this"===i.name?(l=i.type,u=n,st[l.type].unpackInto(a,t,l,r,u)):n[i.name]=o(i.type)}var l,u}}(i);if(void 0!==s.prototype.loadSTRUCT){let t=n;return t||void 0===s.newSTRUCT?t||(t=new s):t=s.newSTRUCT(l),t.loadSTRUCT(l),t}if(void 0!==s.fromSTRUCT)return mt>1&&console.warn("Warning: class "+kt(s.name)+" is using deprecated fromSTRUCT interface; use newSTRUCT/loadSTRUCT instead"),s.fromSTRUCT(l);{let t=n;return t||void 0===s.newSTRUCT?t||(t=new s):t=s.newSTRUCT(l),l(t),t}}readJSON(t,e,r){let n,s;if(n="number"==typeof e?this.struct_cls[this.struct_ids[e].name]:e instanceof a?this.get_struct_cls(e.name):e,void 0===n)throw new Error("bad cls_or_struct_id "+e);s=this.structs[n.structName],vt("\n\n=Begin reading "+n.structName+"=");let i=this,o=!1,c=ot;let l=function(e){return function(n){if(o)return;o=!0;let s=e.fields,a=s.length;for(let o=0;o<a;o++){let a,l=s[o];if(a="this"===l.name?t:t[l.name],void 0===a){console.warn("nstructjs.readJSON: Missing field "+l.name+" in struct "+e.name);continue}let u="this"===l.name?n:r,p=c(i,a,n,l,l.type,u);"this"!==l.name&&(n[l.name]=p)}}}(s);if(void 0!==n.prototype.loadSTRUCT){let t=r;return t||void 0===n.newSTRUCT?t||(t=new n):t=n.newSTRUCT(l),t.loadSTRUCT(l),t}if(void 0!==n.fromSTRUCT)return mt>1&&console.warn("Warning: class "+kt(n.name)+" is using deprecated fromSTRUCT interface; use newSTRUCT/loadSTRUCT instead"),n.fromSTRUCT(l);{let t=r;return t||void 0===n.newSTRUCT?t||(t=new n):t=n.newSTRUCT(l),l(t),t}}}function Jt(t=gt,e=!1){let r="";t.forEach((function(t){r+=jt.fmt_struct(t,!1,!e)+"\n"}));let n=r;r="";for(let t=0;t<n.length;t++){let e=n[t];if("\n"===e){r+="\n";let e=t;for(;t<n.length&&(" "===n[t]||"\t"===n[t]||"\n"===n[t]);)t++;t!==e&&t--}else r+=e}return r}function Lt(t){let e=64;return~~((t=Bt(t)).major*e*e*e+t.minor*e*e+t.micro*e)}gt=new jt,"undefined"==typeof btoa?(Et=function(t){return new Buffer(""+t,"binary").toString("base64")},Ot=function(t){return new Buffer(t,"base64").toString("binary")}):(Ot=atob,Et=btoa);let Yt=/[0-9]+\.[0-9]+\.[0-9]+$/;function Bt(t){if(!t)throw new Error("empty version: "+t);if("string"==typeof t){if(!Yt.exec(t))throw new Error("invalid version string "+t);let e=t.split(".");return{major:parseInt(e[0]),minor:parseInt(e[1]),micro:parseInt(e[2])}}if(Array.isArray(t))return{major:t[0],minor:t[1],micro:t[2]};if("object"==typeof t){let e=e=>e in t&&"number"==typeof t[e];if(!e("major")||!e("minor")||!e("micro"))throw new Error("invalid version object: "+t);return t}throw new Error("invalid version "+t)}function Dt(t,e){return Lt(t)<Lt(e)}class Pt{constructor(){this.magic="STRT",this.ext=".bin",this.blocktypes=["DATA"],this.version={major:0,minor:0,micro:1}}}class zt{constructor(t,e){this.type=t,this.data=e}}class Ft extends Error{}var Wt=Object.freeze({__proto__:null,versionToInt:Lt,versionCoerce:Bt,versionLessThan:Dt,FileParams:Pt,Block:zt,FileeError:Ft,FileHelper:class{constructor(t){if(void 0===t)t=new Pt;else{let e=new Pt;for(let r in t)e[r]=t[r];t=e}this.version=t.version,this.blocktypes=t.blocktypes,this.magic=t.magic,this.ext=t.ext,this.struct=void 0,this.unpack_ctx=void 0}read(t){if(this.unpack_ctx=new g,V(t,this.unpack_ctx,4)!==this.magic)throw new FileError("corrupted file");this.version={},this.version.major=F(t,this.unpack_ctx),this.version.minor=J(t,this.unpack_ctx),this.version.micro=J(t,this.unpack_ctx);let e=this.struct=new jt,r=H(t,this.unpack_ctx);this.struct.parse_structs(r,gt);let n=[],s=t.buffer.byteLength;for(;this.unpack_ctx.i<s;){let r,s=V(t,this.unpack_ctx,4),i=Y(t,this.unpack_ctx),a=Y(t,this.unpack_ctx);-2===a?r=V(t,this.unpack_ctx,i):(r=j(t,this.unpack_ctx,i),r=e.read_object(r,a,new g));let o=new zt;o.type=s,o.data=r,n.push(o)}return this.blocks=n,n}doVersions(t){this.blocks;Dt(t,"0.0.1")}write(t){this.struct=gt,this.blocks=t;let e=[];O(e,this.magic,4),N(e,this.version.major),y(e,255&this.version.minor),y(e,255&this.version.micro),M(e,Jt());let r=this.struct;for(let n of t){if("string"==typeof n.data){O(e,n.type,4),k(e,n.data.length),k(e,-2),O(e,n.data,n.data.length);continue}let t=n.data.constructor.structName;if(void 0===t||!(t in r.structs))throw new Error("Non-STRUCTable object "+n.data);let s=[],i=r.structs[t];r.write_object(s,n.data),O(e,n.type,4),k(e,s.length),k(e,i.id),w(e,s)}return new DataView(new Uint8Array(e).buffer)}writeBase64(t){let e=this.write(t),r="",n=new Uint8Array(e.buffer);for(let t=0;t<n.length;t++)r+=String.fromCharCode(n[t]);return Et(r)}makeBlock(t,e){return new zt(t,e)}readBase64(t){let e=Ot(t),r=new Uint8Array(e.length);for(let t=0;t<e.length;t++)r[t]=e.charCodeAt(t);return this.read(new DataView(r.buffer))}}});function Ht(t=!0){St(t)}function Gt(t){return gt.validateStructs(t)}function Vt(t){let e=h;return _(t),e}function $t(){return h}function Kt(t){return gt.allowOverriding=!!t}function Qt(t){return gt.isRegistered(t)}function Zt(t,e){return gt.register(t,e)}function qt(t){gt.unregister(t)}function Xt(t,e,r=t.name){return jt.inherit(...arguments)}function te(t,e,r){return gt.readObject(t,e,r)}function ee(t,e){return gt.writeObject(t,e)}function re(t){return gt.writeJSON(t)}function ne(t,e){return gt.readJSON(t,e)}export{jt as STRUCT,wt as _truncateDollarSign,$ as binpack,Wt as filehelper,$t as getEndian,Xt as inherit,Qt as isRegistered,gt as manager,d as parser,i as parseutil,ne as readJSON,te as readObject,Zt as register,Kt as setAllowOverriding,Ut as setDebugMode,Vt as setEndian,St as setTruncateDollarSign,Ct as setWarningMode,Ht as truncateDollarSign,f as typesystem,g as unpack_context,qt as unregister,Gt as validateStructs,re as writeJSON,ee as writeObject,Jt as write_scripts};
